# 👏 동적 계획법 (Dynamic Programming, DP)

동적 계획법은 큰 문제를 작은 하위 문제로 나누어 푸는 알고리즘 설계 기법 중 하나입니다. 이를 통해 중복 계산을 피하고 계산 결과를 저장하여 효율적으로 문제를 해결할 수 있습니다.

## 배경

동적계획법의 등장 배경은 피보나치 수열을 통해 알 수 있습니다. 피보나치 수열은 제 2항까지는 1, 제3항부터는 바로 앞의 두 항을 더한 수로 정의됩니다. 수열은 다음과 같습니다.

```
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
```

프로그래밍에서 피보나치 수열은 보통 재귀를 통해 표현합니다. 아래는 피보나치 수열의 n번째 수를 구하는 함수입니다.

```js
function fibo(n) {
  if (n <= 2) return 1
  return fibo(n - 2) + fibo(n - 1)
}
```

fibo(6)은 아래와 같이 실행됩니다.

<p align="center"><img src="https://velog.velcdn.com/images%2Fchelsea%2Fpost%2F627c053e-8a71-48e7-b0b2-7b8d327963a2%2F%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%E1%84%91%E1%85%B5%E1%84%87%E1%85%A9.gif" /></p>

`fibo(4)`의 연산이 두 번, `fibo(3)`의 연산이 세 번 진행되는 것을 볼 수 있습니다. 이미 진행되었던 연산인데도 불구하고 말입니다.

## 동적 계획법의 등장

```
⭐️ 이미 했던 연산의 반복을 보완하자
→ 진행한 연산은 기록해두고, 또 하게 되면 기록되어 있는 값을 이용하자
```

위 예시처럼 이미 했던 연산이 반복되는 결점을 보완하기 위해 동적 계획법(Dynamic Programming, DP)이 고안되었습니다.

## 동적 계획법의 원리

원리는 간단합니다. 처음 진행되는 연산은 기록해 두고, 이미 진행했던 연산이라면 다시 연산하는 것이 아니라 기록되어 있는 값을 가져오는 것입니다.

## 동적 계획법으로 구하는 피보나치 수열

```js
function fibonacciWithDP(n) {
  if (n <= 1) return n

  const dp = new Array(n + 1).fill(0)
  dp[1] = 1

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }

  return dp[n]
}
```

`dp`라는 배열을 생성합니다. 이 배열에는 연산한 값들이 저장될 예정입니다. 그래서 n만큼의 Array를 생성합니다(0부터 시작하기 때문에 n+1).

n이 1 이하일 경우 바로 n을 리턴합니다. dp[0] = 0, dp[1] = 1이기 떄문입니다. 그 이상일 경우, `dp[n]`에 연산 값이 있는지 없는지 검사합니다. 없을 경우, 새로 연산해서 `dp[n]`에 값을 젖아하고 반환합니다. 만약 연산 값이 존재한다면 바로 `dp[n]`을 반환합니다. 재귀와는 다르게 중복되는 연산이 사라지게 됩니다.

## 개념

동적 계획법은 문제를 풀 때 **하나의 문제를 여러 하위 문제로 나누어 풀고**, 그것들을 **결합**해서 최종 목적에 도달하는 방식의 알고리즘입니다.

### 메모이제이션(Memoization)

위 코드에서 하위 문제를 해결할 때 그 해결책을 두고, 똑같은 문제가 발생했을 때 저장되어 있던 해결책을 가지고 간단하게 해결했습니다. 다시 해결책을 만들어내는 것이 아니라요!

이렇게 동일한 문제를 반복해야 할 경우, 한번 계산된 결과를 저장해 두었다가 활용하는 방식으로 중복 계산을 줄이는 것을 **메모이제이션(Memoization)** 이라고 합니다.

### TOP-DOWN

큰 문제부터 문제를 쪼개가며 작은 문제로 만들고 다시 합쳐가며 원래 문제를 푸는 방식입니다.

```
✔️ 시간복잡도: O(n)
```

### BOTTOM-UP

작은 문제들을 모아서 큰 문제를 만들어 쌓아 올려가는 방식입니다.
`bottom-up`은 주로 반복문을 사용하여 구현합니다. 위에서 구현했던 코드도 `bottom-up` 방식입니다.

```
✔️ 시간복잡도: O(n)
```

## 동적 계획법은 특히 여기서

동적 계획법은 특히 최단 경로 문제, 최장 공통 부분 문자열 제거, 배낭 문제 등 다양한 종류의 문제에서 활용되며, 중복 계산을 효과적으로 피하여 게산 복잡도를 줄이는 데 큰 도움을 줍니다.

# 참고문서

- [[자료구조와 알고리즘] 동적 계획법(Dynamic Programming, DP)](https://velog.io/@chelsea/1-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming-DP)
- [자바스크립트로 알고리즘 정리하기 #9 다이나믹 프로그래밍 개념
  ](https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-9-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
