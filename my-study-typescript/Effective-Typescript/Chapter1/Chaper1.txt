🚀 1장 타입스크립트 알아보기
-----------------------------------------------------------------------------------------------------------

1. 타입스크립트와 자바스크립트의 관계 이해하기

    * 관계 : 자바스크립트는 타입스크립트의 부분 집합 
        => 타입스크립트 > 자바스크립트

    * 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것
        => 타입 구문을 추가함으로써
           코드의 '의도'가 무엇인지 타입 구문을 통해 타입스크립트에게 알려줄 수 있기 때문에
           코드의 동작과 의도가 다른 부분을 찾을 수 있다

    * 타입스크립트의 도움을 받으면 오류가 적은 코드를 작성할 수 있다
        => ex. null + 7, [] + 12, ...

    * 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있다
        => 런타임 오류를 발생시키는 코드를 찾아내려고 한다
        => 기본적인 타입스크립트 기능만으로는 모든 타입 오류를 무조건 다 찾지는 못할 수 있다


-----------------------------------------------------------------------------------------------------------

2. 타입스크립트 설정 이해하기

    * 가급적 tsconfig.json 설정 파일을 사용하는 것이 좋음
        => 타입스크립트를 어떻게 사용할 계획인지 동료들이나 다른 도구들이 알 수 있음

        $ tsc --init

    
    {
        "compilerOptions": {
            "noImplicitAny": true, // 코드를 무조건 명시해라 (any라고 하더라도)
            "strictNullCheck": true, // null과 undefined를 허용 X
        }
    }
        => 타입스크립트는 타입 정보를 가질 때 가장 효과적 !
        => 되도록이면 설정하자 ***
        => 타입스크립트가 문제를 발견하기 수월해지고, 코드의 가독성 좋아지고, 개발자의 생산성도 향상

        => 이 모든 설정을 하고 싶다면 strict 설정을 하면 됨 => 대부분의 오류를 잡아낼 수 있음
        => 오류를 잡아내는 데 많은 도움이 되지만, 코드 작성을 어렵게 하기도 한다

    * any 타입을 매개변수에 사용하면 타입 체커는 무력해짐
        -> 매우 유용하지만 주의해서 사용해야 함

    🟡 타입스크립트 프로젝트를 시작했을 때 tsconfig.json 파일 설정을 통해 보다 타입을 얼마나 엄격하게 지킬 것인지
        꼼꼼하게 여러 설정을 통해 정하고 시작하도록 하자

------------------------------------------------------------------------------------------------------------

3. 코드 생성과 타입이 관계없음을 이해하기

    타입스크립트 컴파일러의 두 가지 역할

        (1) 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일(transpile)
        (2) 코드의 타입 오류를 체크

        ※ 두 가지가 서로 완벽히 독립적
            => 타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향 X
            => 자바스크립트의 실행 시점에도 타입은 영향 X

    ✨ 타입스크립트가 할 수 있는 일과 할 수 없는 일

        🟢 타입 오류가 있는 코드도 컴파일이 가능

            -> 컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능
            -> 문제가 될 만한 부분을 알려주지만, 그렇다고 빌드를 멈추지는 X

            참고) C나 자바는 타입체크와 컴파일이 동시에 이루어져 오류가 있을 경우 빌드를 멈춤

            참고) 만약 오류가 있을 때 컴파일하지 않도록 하려면,

                tsconfig.json -> noEmitOnError: true 설정

        🔴 런타임에는 타입 체크가 불가능

            자바스크립트가 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버림

            * 런타임 시 타입 정보를 유지하는 방법

                (1) 해당 속성이 있는 지를 체크해보기

                    ex) const calculateArea(shape: Shape) {
                            if('height' in shape) {
                                shape; // 타입이 Rectangle
                                return shape.width * shape.height
                            }
                        }

                    => 속성 체크는 런타임에 접근 가능한 값에만 관련되지만, 
                       타입 체커 역시도 shape의 타입을 Rectangle로 보정해 주기 때문에 오류가 사라짐

                (2) '태그' 기법

                    ex) const calculateArea = (shape: Shape) => {
                            if (shape.kind === 'rectangle') {
                                return shape.width * shape.height;
                            } else {
                                return shape.width * shape.width;
                            }
                        };
                      
        🔴 타입 연산은 런타임에 영향을 주지 X

            ex) const asNumber = (val: number | string): number => {
                    return val as number;
                };

                위 함수를 자바스크립트로 변환하면

                function asNumber(val) {
                    return val
                }

                -> 코드에 아무런 정제 과정 X
                -> as Number는 타입 연산이고 런타임 동작에는 아무런 양향 X
                => 값을 정제하기 위한 목적으로 타입 연산을 사용하는 것은 의미 X

                따라서 아래와 같이 타입을 체크하는 방법이 적절

                function asNumber(val: number | string): number {
                    return typeof(val) === 'string' ? Number(val) : val;
                }

        🔴 런타임 타입은 선언된 타입과 다를 수 있다

            * 타입스크립트는 죽은(dead) 코드(실행되지 못하는)를 찾아내지만, 

                function setLightSwitch(value: boolean) {
                    switch (value) {
                        case true:
                        turnLightOn();
                        break;
                        case false:
                        turnLightOff();
                        break;
                        default:
                        console.log('실행되지 않았음');
                    }
                }

                위 코드에서는 strict를 설정하더라도 찾아내지 못함. 그러면 마지막 부분을 실행할 수 있는 경우는 무엇일까 ?

                    : boolean이 타입 선언문이라는 것에 주목

                     => 타입스크립트의 타입이기 때문에 : boolean은 런타임에 제거됨
                     => 자바스크립트라면 실수로 setLightSwitch("ON")으로 호출할 수도 있을 것

                interface LightApiResponse {
                        lightSwitchValue: boolean;
                    }

                    async function setLight() {
                    const response = await fetch('/light');
                    const result: LightApiResponse = await response.json();
                    setLightSwitch(result.lightSwitchValue);
                }

                    /light를 요청하면 그 결과로 LightApiResponse를 반환하라고 선언했지만,
                    실제로 그렇게 되리라는 보장은 없음

                    API를 잘못 파악해서 lightSwitchValue가 실제로는 문자열이었다면?
                        -> 런타임에는 setLightSwitch 함수까지 전달될 것

                    => 타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있다
                    그렇지만, 타입이 달라지는 혼란스러운 상황을 가능한 한 피해야 할 것

                    * 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 한다


        🔴 타입스크립트 타입으로는 함수를 오버로드할 수 없다

            C++ 같은 언어는 동일한 이름에 매개변수만 다른 여러 버전의 함수를 허용 -> 함수 오버로딩 허용

            그러나 타입스크립트는 타입과 런타임의 동작이 무관하기 때문에 함수 오버로딩 X
                                 ---------------------------            
            * 타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 온전히 타입 수준에서만 동작한다
              하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만, 구현체(implementation)은 오직 하나뿐


        🟢 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

            타입과 타입 연산자는 자바스크립트 변환 시점에 제거 -> 런타임에 아무런 영향 X

            ** 타입스크립트의 정적 타입은 실제로 비용이 전혀 X

-----------------------------------------------------------------------------------------------------------------------

4. 구조적 타이핑에 익숙해지기

    자바스크립트는 본질적으로 덕 타이핑(duck typing) 기반
        -> 그래서 매개변수 값이 요구사항을 만족한다면 타입이 무엇인지 신경 쓰지 않는 동작을 그대로 모델링한다

        * 덕 타이핑(duck typing)
            객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식

    ==> 구조적 타이핑을 제대로 이해한다면, 오휴인 경우와 오류가 아닌 경우의 차이를 알 수 있고
        더욱 견고한 코드를 작성할 수 있다

----------------------------------------------------------------------------------------------------------------------------

5. any 타입 지양하기

    타입스크립트의 타입 시스템은 점진적(gradual)이고 선택적(optional)

        -> 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적,
           언제든지 타입 체커를 해제할 수 있기 때문에 선택적

        => 이 기능들의 핵심은 any 타입 !

        let age: number;
        // age = '12'; // error
        age = '12' as any; // OK

        타입 선언을 추가하는 데에 시간을 쏟고 싶지 않아 any 타입이나 타입 단언문(as any)를 사용하기도...
        그러나 일부 특별한 경우를 제외하고는 any를 사용하면
        타입스크립트의 수많은 장점을 누릴 수 없게 된다.

        ** any 타입의 위험성 ** 

        🔴 any 타입에는 타입 안전성이 없다
            as any를 사용하면 바로 선언했던 타입과는 다른 타입을 할당할 수 있게 된다.


        🔴 any는 함수 시그니처를 무시해 버린다.
            함수를 작성할 때는 '시그니처'를 명시해야 한다.

                -> 호출하는 쪽은 약손된 타입의 입력을 제공, 함수는 약속된 타입의 출력을 반환
                    그러나 any를 입력하면 이런 약속을 모두 어길 수 있음

        🔴 any 타입에는 언어 서비스가 적용 X
            any 타입으로 선언하게 되면 자동완성 기능을 사용 X

            타입스크립트의 모토 : 확장 가능한 자바스크립트 !
                -> '확장'의 중요한 부분 -> 타입스크립트 경험의 핵심 요소인 '언어 서비스(자동완성)'
                -> 제대로 사용해야 생산성 향상 🔥

        🔴 any 타입은 코드 리팩토링 때 버그를 감춘다

        🔴 any는 타입 설계를 감춰버린다
            애플리케이션 상태 객체를 정의하려면 꽤 복잡하다.
            상태 객체 안에 있는 수많은 속성의 타입을 일일이 작성해야 하는데, any 타입을 사용하면 간단히 끝내버릴 수 있다.

            => 물론 이때도 any를 사용하면 XXXXX

                any로 선언해 버리면, 상태 객체의 설계를 모두 감춰버린다.
                                     타입 설계가 불분명해진다.

            => 설계가 명확히 보이도록 '타입을 일일이 작성'하는 것이 좋다

        🔴 any는 타입시스템의 신뢰도를 떨어뜨린다
            타입 체커가 실수를 잡아주고 코드의 신뢰도가 높아진다.
            그러나 런타임에 타입 오류를 발견하게 된다면 타입 체커를 신뢰

            => any 타입을 쓰지 않으면 런타임에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높일 수 있다 🔥 

                그렇지만, 어쩔 수 없이 any를 써야만 하는 상황도 있음

