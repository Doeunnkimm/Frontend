## 올바른 테스트 작성을 위한 규칙은 뭐가 있을까 ?

### 1. 인터페이스를 기준으로 테스트를 작성하자

> 인터페이스: 서로 다른 클래스 또는 모듈이 상호작용하는 시스템

- 즉 모든 테스트는 세부 구현을 테스트하는 대신 외부에 노출되는 인터페이스를 기준으로 작성해야 한다.
- 캡슐화된 내부 구현에 대한 테스트 코드는 수많은 테스트 코드를 양산할 뿐만 아니라, 내부 구현과의 강한 의존성 때문에 구현이 조금만 변경해도 유지보수하기가 굉장히 힘들다.

```js
// 잘못된 테스트 코드
it('itShowModal 상태를 true로 변경했을 때 ModalComponent의 display 스타일이 block이며, "안녕하세요!" 텍스트가 노출된다.', () => {
  // 구현에 종속적인 코드와 복잡한 상태 변경 코드들이 발생할 수 있습니다.
  SpecificComponent.setState({ isShowModal: true })

  // ...
})
```

- 변경되는 상태가 많은 경우 테스트 코드 상에서 일일이 직접 변경해야 하며
- 어떤 상황에서 변경 되는 것인지 드러나지 않는다.
- 내부 상태나 변수값을 기준으로 검증하다 보니 어떤 것을 검증하는지 테스트 코드만 보고 한 눈에 파악하기 어렵다.
- 내부 구현을 검증하려다 보니 구현에 종속적인 테스트 코드가 양산된다.
- 상태나 변수명이 하나라도 바뀌면 테스트 코드 모두를 바꿔야 한다.
- 즉, **캡슐화를 위반하는 코드**가 된다.

**🤔 컴포넌트에서 상태를 변경할 수 있도록 제공되는 인터페이스는 ?**

> DOM event handler

```js
// 올바른 테스틐 코드
it('버튼을 누르면 모달을 띄운다', () => {
  // 유저의 동작과 비슷하도록 클릭 이벤트를 발생
  user.click(screen.getByRole('button'))

  // ...
})
```

- 내부 구현과 종속성이 없으며 캡슐화에 위반되지 않는다.
- 어떤 행위를 하는지 명확해진다.
- 테스트를 설명하기 위한 불필요한 주석이나 설명 또한 없다.

### 2. 커버리지 보다는 의미있는 테스트인지 고민하자

- 테스트를 작성하면서 가장 많이 하는 실수가 100% 커버리지를 위해 모든 것을 테스트 코드로 검증하려는 것
- 그 값에만 의존해 유의미한 테스트 코드 작성을 놓치는 경우가 많다.

> 커버리지: 테스트 코드가 프로덕션 코드의 몇 %를 검증하고 있는지 나타낸 지표

- 테스트 작성, 실행, 유지보수 측면에서 너무 많은 비용이 발생
- 100% 커버리지로 테스트를 작성했어도 잘못된 검증 때문에 문제가 발생할 수 있다.

> 커버리지만을 위한 검증은 의미없는 테스트가 될 가능성이 높다

**💡 100% 커버리지를 위한 테스트 보다는...**

- 의미 있는 테스트인지?
- 어떤 범위까지 검증해야 효율적인 테스트가 될지?

고민해야 한다!

### 3. 테스트 코드도 유지보수의 대상! 가독성을 높이자

- 테스트 코드도 애플리케이션의 변화에 따라 끊임없이 유지보수 되어야 하는 코드이다.

1. 테스트 하고자 하는 내용을 명확하게 적자. 테스트 코드만 봐도 애플리케이션이 어떻게 동작하는 지 파악하기 쉽도록 하자.

```js
// 잘못된
it('리스트에서 항목이 제대로 삭제된다.', () => { ... })

// 올바른
it('항목들을 체크한 후 삭제 버튼을 누르면 리스트에서 체크된 항목들이 삭제된다.', () => { ... })
```

2. 하나의 테스트에서는 가급적 하나의 동작만 검증하자

- 단일 책임 원칙: 모든 클래스는 하나의 책임만 갖고 그와 관련된 책임을 캡슐화하여 변경에 견고한 코드를 만들어야 한다.
- 다양한 컴포넌트들이 조합된 시나리오를 테스트해야 한다면 하나의 테스트에서 한번에 검증하는 것이 아니라 여러 개로 나누어 검증하는 것이 가독성과 유지보수에 좋다.

  ```js
  // 잘못된
  it('장바구니에 담긴 상품들이 정상적으로 노출되고, 수량을 변경하면 각격이 재계산된다. 그리고 삭제 버튼을 누르면 상품이 삭제된다.', () => { ... })
  ```

  - description도 장황해져 가독성이 떨어진다.
  - 여러 개를 검증하다보니, 가격 개선에 대한 로직만 수정되어도 테스트 자체가 깨져버린다.
  - 어떤 동작에서 테스트가 실패했는지 파악하기도 힘들다

  ```js
  // 올바른
  it('장바구니에 담긴 상품들을 정상적으로 렌더링 한다.', () => { ... })
  it('장바구니에 담긴 상품의 수량을 수정하면 가격이 재계산된다.', () => { ... })
  it('장바구니에 담긴 항목의 삭제 버튼을 누르면 리스트에서 삭제된다.', () => { ... })
  ```
