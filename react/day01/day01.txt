React?
    복잡한 사용자 인터페이스(UI)를 쉽게 구축하기 위해 페이스북에서 제작한 라이브러리

라이브러리? (도서관 = 모듈들의 집합)

        프레임워크와 라이브러리

            * 프레임워크
                코드를 작성할 때 필요한 틀을 제공해주는 것
                따라서 개발을 할 때 제어권이 개발자가 아닌 프레임워크에 존재,
                개발할 때 프레임워크가 가지고 있는 규칙에 의해 작성
            ex) Spring, Django, nextJS, nuxtJs

            * 라이브러리
                같은 로그인 로직이라 하더라고 passportJS, geture,
                즉 사용자는 특정 정해져있는 코드를 사용하는 것이 아니라,
                필요로 하는 라이브러리를 선택해서 코드를 적용
            ex) nodeJS에 설치되는 모든 패키지와 reactJS, jquery


-------------------------------------------------------------------------------------

React의 JS 구동원리 핵심 컨셉

Components
- 하나의 페이지를 한 가지 이상의 기능을 수행하는 UI 단위로 분리한 것
- 재사용이 용이하고 관리 및 유지 보수에 효율적

Virtual DOM
- react가 가지고 있는 가상 돔, 돔의 복사본
- state(상태)를 react에서 구독(감시), 만약 state의 변화가 생긴다면 그때
    가상돔과 실제돔을 비교하여 수정된 부분만을 실제돔에 리렌더링

1. state의 변화가 생긴다면
2. 수정된 부분(컴포넌트)만을 실제 돔에 리렌더링
(...렌더링 최적화)


key point
---------
state(상태, 값)
Components(UI 분리)
Virtual Dom(re렌더링)


-------------------------------------------------------------------------------------

CSR, SSR

CSR (Client Side Rendering)

    * 사용자가 웹 페이지를 그린다!
    사용자가 웹 페이지에 접속 -> 프론트엔드 서버에 페이지를 렌더링할 때 필요한 리소스를 전달

    ex) 페이지가 로드 되었을 때 상품 목록을 그려준다.
        이 상품 목록은 백엔드 서버로부터 응답 받은 데이터이다.
    
    위의 과정을 사용자가 하게되는 것
    사용자가 렌더링을 부담

    장점
        페이지의 필요한 리소스를 사전에 미리 불러와 데이터를 캐싱(저장)하고 있다가
        URL에 맞는 페이지를 보여주기 때문에 초기 렌더링 이후의 렌더링 속도가 빠르다.

    단점   
        초기 페이지 로딩이 SSR보다 느리다.
        SEO(검색엔징최적화)에 불리
        검색엔진에 노출이 필요한 사이트 부적합( 페이지가 검색엔진이 검색하였을 때 빈화면이 노출 )


SSR (Server Side Rendering)

    * 서버에서 페이지를 그린다!
    사용자가 웹 페이지에 접속 -> 서버에서 페이지를 렌더링 -> 렌더링된 페이지를 사용자에게 전달
    js가 로드 되기도 전에 완성된 페이지를 사용자가 먼저 확인

    장점
        SEO 유리 => 웹 사이트를 검색엔진이 크롤링하여 사용자에 제공 가능
        빠른 완성본 페이지 로딩 속도
        서버에서 렌더링을 부담하기 때문에 사용자가 느끼는 부담이 덜하다

    단점
        서버의 부담 (생산 비용 증가)
        무거운 페이지라면 오히려 초기 로딩이 CSR보다 오래 걸릴 가능성
        CSR보다 더 많은 생산비용, 초기 러닝 커브

React는 대표적인 CSR, SPA

-------------------------------------------------------------------------------------

 SPA, MPA

 SPA (Single Page Application)

    페이지 하나인 애플리케이션(.html 파일이 1개)
    reactJS와 같은 컴포넌트 기반 라이브러리 및 프레임워크는 SPA에 최적화
    사용자가 웹 사이트에 접속 당시 번들링 된 리소스들을 한번에 전달

    그리고 이를 캐싱해 두었다가 url이 달라짐에 따라 html의 내부를 수정하여
    사용자에게 보내주는 것

    따라서 통상적으로 react의 파일 구조는 index.html 하나로만 구성되어 있음

MPA (Multi Page Application)

    페이지가 여러 개인 애플리케이션 (.html 파일이 여러 개)
    보통은 SSR 방식으로 요청마다 해당 페이지에 필요한 리소스를 불러온다.


-------------------------------------------------------------------------------------

* REACT는 CSR과 SPA에 최적화 되어있다.

-------------------------------------------------------------------------------------

    패키지 관리 툴

            라이브러리들을 관리하고 설치할 수 있는 도구
            npm, npx, yarn, yarn berry

    * npm
        nodejs에서 기본적으로 내장되어 있는 패키지 관리 툴
        ex) npm i(install) 라이브러리명 (--save) - 설치
            npm rm(remove) 라이브러리명 - 삭제

            npm i -g 라이브러리 (노드 환경 전역에서 설치)
            npm i -D 라이브러리 (개발환경에서만 사용할 라이브러리르 설치)

            ex) 디버깅툴은? 개발자만 == 사용자 굳이 볼 필요X

    nodeJS
    https://nodejs.org/

    설치 확인
    node -v

    * npx
        npm과 달리 설치하지 않고 라이브러리를 실행 시켜주는 도구
        사실 개발하는 입장이라면 npm과 npx 차이를 느끼지 못할 수도 있음
        단, npx를 사용해야 하는 경우는 내 프로젝트에 설치하지 않고
        일회성으로 무거운 패키지를 사용해야 할 때 설치하지 않고 실행하는 패키지 관리 툴
        npx도 마찬가지로 npm에 기본 설치(5.2v 이상)

        ex) npx create-react-app 프로젝트명 : react 프로젝트를 생성하는 명령어 (CRA)

    * yarn
        과거에는 npm보다 속도, 안정성, 보안 모두 뛰어나서 이목을 끌었다 npm의 잦은 업데이트로
        현재는 거의 차이가 없는 상태, 보안성은 제외

    * yarn berry
        npm과 yarn의 경우 설치된 라이브러리들은 node_modules라고하는 파일에 저장
        pnp 방식을 도입 zero install
        알집으로 파일을 관리하고 있기 때문에 프로젝트 자체가 가볍도 빌드가 빨라진다.

        ** 모노래포
        => 하나의 워크스페이스(폴더)를 통해 여러 개의 프로젝트를 담고 관리할 수 있음

        본래 모노래포는 yarn과 turbo 라이브러리를 통해 구축하였으나
        yarn berry는 보다 모노래포에 최적화 되어있는 패키지 관리 툴

        그러나, 다른 프로젝트를 한 폴더에 둔다는 것은 폴더의 구조나 신경써야 하는 부분들이
        배로 늘어난다는 이야기. 따라서 초기에 적용하지 않는 것은 좋지 않고
        이미 사용자가 충분히 확보된 복잡한 프로젝트를 간단하게 만들기 위해 사용


-------------------------------------------------------------------------------------

* React 생성

1. 터미널 명렁어를 통해 내가 프로젝트를 생성하고자 하는 위치 경로를 맞춰야 함
2. 명령어
    create-react-app (CRA) webpack5(번들링도구)
    
    vite esBuild
    초보자가 사용하기에 적합하지 않음
    CRA는 react에서 직접 만든 명령어 -> 굉장히 편리한 라이브러리들이 이미 설치 및 세팅

    CRA는 react에 필요한 모든 설정 파일을 대신 설정 (웹팩과 같은 번들링 도구, 바벨과 같은 트랜스파일러)
    
    단점, 이미 설치된 도구를 커스텀하기 힘들다. 보통의 경우 커스텀을 할 때는
    carco와 같은 cra 전용 설정 라이브러리를 통해 커스텀 해야한다.

3. npx create-react-app 프로젝트명 
    * 폴더 경로 꼭 확인!
        cd ex1
        npm start

    * react 실행의 기본 port는 3000번
    따라서 프로젝트 실행 시 기본 주소는 http://localhost:3000/
                                              ----------
                                                  127.0.0.1

    여러분이 프로젝트가 실행 중일 때는 3001, 3002, 3003

---------------------------------------------------------------------------------------------------------

webpack

    모듈 번들러
        모듈 => 한가지 이상의 기능을 하는 분리된 코드의 집합, 덩어리
        번들러 = 묶어주는 것

        html, css, js, img
        너저분하게 분리되어 있는 리소스들을 확장자명 혹은 특정 기준으로 분류하고 묶어주는 역할

        모듈 번들러의 웹팩을 사용하면 잘 정돈 되어있는 데이터에서 필요한 리소스만 찾을 수 있기 때문에
        네트워크 연산 비용이 줄어들게 됨

        1. 모듈 단위의 개발이 가능
        2. 네트워크 연산 비용 감소
        3. loader라는 기능을 통해 js가 로드할 수 없는 파일도 로드할 수 있는 상태로 컴파일(변환)

babel

    트랜스파일러 (번역기)
    
    ES6(ES2015) 이후 - 모던 자바스크립트
    es-next
    es-2020

    최신 문법들을 이해하지 못하는 웹 브라우저 로더들이 해당 언어를 이해할 수 있도록
    저레벨의 문법으로 트랜스파일하여 이해할 수 있도록 변환

    * react에서 babel 총 4가지 모듈을 사용

    1. @babel/core              바벨을 구동시키기 위한 핵심 요소
    2. @babel/cli               명령어를 통해 cmd에서 바벨 명령어 사용 가능
    3. @babel/preset-env        바벨의 가장 기본적인 설정들
    4. @babel/preset-React      바벨을 JSX문법도 이해할 수 있도록 해주는 모듈

    JSX(react 문법)

----------------------------------------------------------------------------------------------------------

리액트 프로젝트 구조

    node_modules - 현재 프로젝트에 설치된 라이브러리들의 실제 파일
                    용량이 높은편 그래서 git에는 올리지 않음

    public - 정적 파일 보관소 (index.html, favicon, seo)
    ** src - 개발이 진행될 곳
    .gitignore - git에 올라가지 않아야 할 파일
    README.md
    
    package.json - 설치된 라이브러리의 목록과 버전을 관리, 실행 스크립트(명령어)와 프로젝트 설정
    package-lock.json - 라이브러리 설치 시, 라이브러리 설치에 필요한 정확한 정보

    * npm install

----------------------------------------------------------------------------------------------------------

    src의 구조

----------------------------------------------------------------------------------------------------------