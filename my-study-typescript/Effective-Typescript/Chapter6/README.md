# 6장 타입선언과 @types

- 타입스크립트를 포함한 모든 언어들에서 라이브러리 의존성 관리는 어려운 일이다.
- 6장에서는 타입스크립트에서 의존성이 어떻게 동작하는지 설명하여 의존성에 대한 개념을 잡을 수 있게 한다.
- 또한 의존성 관리를 하다가 맞닥뜨릴 수 있는 몇 가지 문제를 보여 주고 해결하는 방법을 찾아본다.
- 이런 것들이 프로젝트를 공개하기 전에 타입 선언 파일을 작성하는 데 도움이 될 것이다.
- 제대로 된 타입 선언문을 작성하여 공개하는 것은 프로젝트뿐만 아니라 타입스크립트 전체 커뮤니티에 기여하는 일이기도 하다.

---

## 🌱 아이템45. devDependencies에 typescript와 @types 추가하기

- npm(node package manager)은 자바스크립트 세상에서 필수적이다.
- npm은 자바스크립트 라이브러리 저장소(npm 레지스트리)와, 프로젝트가 의존하고 있는 라이브러리들의 버전을 지정하는 방법(package.json)을 제공한다.
- npm은 세 가지 종류의 의존성을 구분해서 관리하며, 각각의 의존성은 package.json 파일 내의 별도 영역에 들어 있다.

<br>

**✔️ dependencies**

- 현재 프로젝트를 실행하는 데 필수적인 라이브러리들이 포함된다.
- 프로젝트 런타임에 lodash가 사용된다면 dependencies에 포함되어야 한다.
- 프로젝트를 npm에 공개하여 다른 사용자가 해당 프로젝트를 설치한다면, dependencies에 들어 있는 라이브러리도 함께 설치될 것이다.
- 이러한 현상을 전이(transitive) 의존성이라고 한다.

<br>

**✔️ devDependencies**

- 현재 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요없는 라이브러리들이 포함된다.
- 예를 들어, 프로젝트에서 사용 중인 테스트 프레임워크가 devDependencies에 포함될 수 있는 라이브러리이다.
- 프로젝트를 npm에 공개하여 다른 사용자가 해당 프로젝트를 설치한다면, devDependencies에 포함된 라이브러리들은 제외된다는 것이 dependencies와 다른 점이다.

<br>

**✔️ peerDependencies**

- 런타임에 필요하긴 하지만, 의존성을 직접 관리하지 않는 라이브러리들이 포함된다.
- 단적인 예로 플러그인을 들 수 있다.
- 제이쿼리의 플러그인은 다양한 버전의 제이쿼리와 호환되므로 제이쿼리의 버전을 플러그인에서 직접 선택하지 않고, 플러그인이 사용되는 실제 프로젝트에서 선택하도록 만들 때 사용한다.

<br>

- 이 세 가지 의존성 중에서는 dependencies와 devDependencies가 일반적으로 사용된다.
- 타입스크립트 개발자라면 라이브러리를 추가할 때 어떤 종류의 의존성을 사용해야 하는지 알고 있어야 한다.
- 타입스크립트는 개발 도구일 뿐이고 **타입 정보는 런타임에 존재하지 않기 때문에**, 타입스크립트와 관련된 라이브러리는 **일반적으로 devDependencies**에 속한다.

<br>

- 모든 타입스크립트 프로젝트에서 공통적으로 고려해야 할 의존성 두 가지를 살펴보자

**✔️ 타입스크립트 자체 의존성 고려**

- 타입스크립트를 시스템 레벨로 설치할 수도 있지만, 다음 두 가지 이유 때문에 추천하지 않는다.
  ```
  1. 팀원들이 모두가 항상 동일한 버전을 설치한다는 보장이 없다.
  2. 프로젝트를 셋업할 때 별도의 단계가 추가된다.
  ```
- 따라서 타입스크립트를 시스템 레벨로 설치하기보다는 devDependencies에 넣는 것이 좋다.
- devDependencies에 포함되어 있다면, npm install을 실행할 때 팀원들 모두 항상 정확한 버전의 타입스크립트를 설치할 수 있다.
- 그리고 타입스크립트 버전 업데이트는 다른 라이브러리의 업데이트와 같은 방법을 사용하게 된다.
- 대부분의 타입스크립트 IDE와 빌드 도구는 devDependencies를 통해 설치된 타입스크립트의 버전을 인식할 수 있도록 되어 있다.
- 또한 커맨드 라인에 npx를 사용해 devDependencies를 통해 설치된 타입스크립트 컴파일러를 실행할 수 있다.
  ```bash
  $ npx tsc
  ```

<br>

**✔️ 타입 의존성(@types) 고려**

- 사용하려는 라이브러리에 타입 선언이 포함되어 있지 않더라도, `DefinitelyTyped(타입스크립트 커뮤니티에서 유지보수하고 있는 자바스크립트 라이브러리의 타입을 정의한 모음)`에서 타입 정보를 얻을 수 있다.
- `DefinitelyTyped`의 타입 정의들은 npm 레지스트리의 @types 스코프에 공개된다.
- 즉, @types/jquery에는 제이쿼리의 타입 정의가 있고, @types/lodash에는 로대시의 타입 정의가 있다.
- @types 라이브러리는 타입 정보만 포함하고 있으며 구현체는 포함하지 않는다.
- 원본 라이브러리 자체가 dependencies에 있더라도 @types 의존성은 devDependencies에 있어야 한다.
- 예를 들어, 리액트의 타입 선언과 리액트를 의존성에 추가하려면 다음처럼 실행한다.
  ```bash
  $ npm install react
  $ npm install -D @types/react
  ```
- 그러면 다음과 같은 package.json 파일이 생성된다.
  ```json
  {
    "devDependencies": {
      "@types/react": "^16.8.19",
      "typescript": "^3.5.3"
    },
    "dependencies": {
      "react": "^16.8.6"
    }
  }
  ```
- 이 예제의 의도는 런타임에 @types/react와 typescript에 의존하지 않겠다는 것이다.
- 그러나 타입 의존성은 devDependencies에 넣는 방식이 항상 유효한 것은 아니며 @types 의존성과 관련된 몇 가지 문제점이 있다.
- @types 의존성과 관련된 문제는 아이템 46에서 자세히 다룬다.

---

## 🌱 아이템46. 타입 선언과 관련된 세 가지 버전 이해하기

- 의존성 관리는 개발자에게 매우 힘든 일이다.
- 그래서 단순히 라이브러리를 프로젝트에 추가해서 사용할 뿐이지 라이브러리의 **전이적(transitive) 의존성이 호환되는지** 깊게 생각하지 않았을 것이다.
- 그런데 실제로 타입스크립트는 알아서 의존성 문제를 해결해 주기는커녕, 의존성 관리릉 오히려 더 복잡하게 만든다.
- 왜냐하면 타입스크립트를 사용하면 **다음 세 가지 사항을 추가로 고려**해야 하기 때문이다.

  ```
  1. 라이브러리의 버전
  2. 타입 선언(@types)의 버전
  3. 타입스크립트의 버전
  ```

  - 세 가지 버전 중 하나라도 맞지 않으면, 의존성과 상관없이 보이는 곳에서 엉뚱한 오류가 발생할 수 있다.
  - 이렇게 발생한 오류의 원인을 파악하고 고치기 위해서는 타입스크립트 라이브러리 관리의 복잡한 메커니즘을 모두 이해해야 한다.
  - 라이브러리 관리의 매커니즘을 이해하게 된다면 프로젝트 내에서 작성한 타입 선언을 외부에 공개해야 하는 시점이 되었을 때, 버전과 관련해서 제대로 된 결정을 내릴 수 있다.

  <br>

  - 타입스크립트에서 일반적으로 의존성을 사용하는 방식은 다음과 같다.
  - 특정 라이브러리를 dependencies로 설치하고, 타입 정보는 devDependencies로 설치한다.

    ```bash
    $ npm install react
    + react@16.8.6

    $ npm install -D @types/react
    + @types/react@16.8.19
    ```

    - 메이저 버전과 마이너 버전(16.8)이 일치하지만 패치 버전(.과 .19)은 일치하지 않는다는 점을 주목하길 바란다.
    - @types/react의 16.8.19는 타입 선언들이 리액트 16.8 버전의 API를 나타낸다는 것을 의미한다.
    - 만약 리액트 모듈이 시맨틱(semantic) 버전 규칙을 제대로 지킨다고 가정하면 패치 버전들(16.8.1, 16.8.2, ...)은 공개 API의 사양을 변경하지 않는다.
    - 따라서 타입 선언을 업데이트할 필요가 없다.
    - 그러나 타입 선언 자체에도 버그나 누락이 존재할 수 있으며 @types 모듈의 패치 버전은 버그나 누락으로 인한 수정과 추가에 따른 것이다.
    - 앞선 예제의 경우 라이브러리 자체보다 타입 선언에 더 많은 업데이트가 있었다(19대 6)

  <br>

  - 그러나 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 다음 네 가지 문제점이 있다.

    <br>
      
    **✔️ 라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않은 경우**

    - 이런 경우 라이브러리 업데이트와 관련된 새로운 기능을 사용하려 할 때마다 타입 오류가 발생하게 된다.
    - 특히 하위 호환성이 깨지는 변경이 있었다면, 코드가 타입 체커를 통과하더라도 런타임에 오류가 발생할 수 있다.
    - 일반적인 해결책은 타입 선언도 업데이트하여 라이브러리와 버전을 맞추는 것이다.
    - 그러나 업데이트해야 할 타입 선언의 버전이 아직 준비되지 않은 경우라면 두 가지 선택지가 있다.
      - 보강(argument) 기법을 활용하여, 사용하려는 새 함수와 메서드의 타입 정보를 프로젝트 자체에 추가하는 것
      - 타입 선언의 업데이트를 직접 작성하고 공개하여 커뮤니티에 기여하는 방법

    <br>

    **✔️ 라이브러리보다 타입 선언의 버전이 최신이 경우**

    - 이런 경우는 타입 정보 없이 라이브러리를 사용해 오다가 타입 선언을 설치하려고 할 때 뒤늦게 발생한다.
    - 그 사이에 라이브러리와 타입 선언의 새 버전이 릴리스되었다면 라이브러리와 타입 선언의 버전 정보는 어긋나게 될 것이다.
    - 첫 번째 문제와 상황이 비슷하지만 버전의 대소 관계가 반대이다.
    - 타입 체커는 최신 API를 기준으로 코드를 검사하게 되지만 런타임에 실제로 쓰이는 것은 과거 버전이다.
    - 해결책은 라이브러리와 타입 선언의 버전이 맞도록 라이브러리 버전을 올리거나 타입 선언의 버전을 내리는 것이다.

    <br>

    **✔️ 프로젝트에서 사용하는 타입스크립트 버전과 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우**

    - 일반적으로 로대시(lodash), 리액트(React), 람다(Ramda) 같은 유명 자바스크립트의 타입 정보를 더 정확하게 표현하기 위해서 타입스크립트에 타입 시스템이 개선되고 버전이 올라가게 된다.
    - 그러므로 이러한 라이브러리들의 최신 타입 정보를 더 정확하게 표현하기 위해서 타입스크립트에서 타입 시스템이 개선되고 버전이 올라가게 된다.
    - 그러므로 이러한 라이브러리들의 최신 타입 정보를 얻기 위해서라면 당연히 타입스크립트의 최신 버전을 사용해야 한다.
    - 현재 프로젝트보다 라이브러리에게 필요한 타입스크립트 버전이 높은 상황이라면 @types 선언 자체에서 타입 오류가 발생하게 된다.
    - 이 오류를 해결하려면 프로젝트의 타입스크립트 버전을 올리거나, 라이브러리 타입 선언의 버전을 원대대로 내리거나 declare module 선언으로 라이브러리의 타입 정보를 없애 버리면 된다.
    - 라이브러리에서 typesVersions를 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 방법도 있지만 실제로는 매우 드물다.
    - 최근까지도 DefinitelyTyped의 라이브러리들 중 1% 미만에서만 typesVersions을 제공한다.
    - 타입스크립트의 특정 버전에 대한 타입 정보를 설치하려면 다음처럼 실행하면 된다.
      ```bash
      $ npm i -D @types/lodash@ts3.1
      ```
    - 라이브러리와 타입 선언의 버전을 일치시키는 것이 최선이겠지만, 상황에 따라 해당 버전의 타입 정보가 없을 수도 있다.
    - 그러나 유명한 라이브러리일 수록 버전별로 타입 선언이 존재할 가능성이 크다.

    <br>

    **✔️ @types 의존성이 중복될 수 있다.**

    - @types/foo와 @types/bar에 의존하는 경우를 가정해 보자.
    - 만약 @types/bar가 현재 프로젝트와 호환되지 않는 버전의 @types/foo에 의존한다면 npm은 중첩된 폴더에 별도로 해당 버전을 설치하여 문제를 해결하려고 한다.
    - 런타임에 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임스페이스(name-space)에 있는 타입 선언 모듈이라면 대부분 문제가 발생한다.
    - 전역 네임 스페이스에 타입 선언이 존재하면 중복된 선언, 또는 선언이 병합될 수 없다는 오류로 나타나게 된다.
    - 이런 상황이라면 `npm ls @types/foo`를 실행하여 어디서 타입 선언 중복이 발생했는지 추적할 수 있다.
    - 해결책은 보통 @types/foo를 업데이트하거나 @types/bar를 업데이트해서 서로 버전이 호환되게 하는 것이다.
    - 그러나 @types이 전이(transitive) 의존성을 가지도록 만드는 것은 종종 문제를 일으키기도 한다.
    - 만약 타입 선언을 작성하고 공개하려고 한다면, 아이템 51을 참고하여 이러한 문제를 피하기 바란다.

  <br>

- 일부 라이브러리, 특히 타입스크립트로 작성된 라이브러리들은 자체적으로 타입 선언을 포함(번들링, bundling)하게 된다.
- 자체적인 타입 선언은 보통 package.json의 "types" 필드에서 .d.ts 파일을 가리키도록 되어 있다.
  ```json
  {
    "name": "left-pad",
    "version": "1.3.0",
    "description": "String left pad",
    "main": "index.js",
    "types": "index.d.ts"
    // ...
  }
  ```
  - "types": "index.d.ts"를 추가하면 모든 문제가 해결될까?

<br>

- 번들링하여 타입 선언을 포함하는 경우, 특히 라이브러리가 타입스크립트로 작성되고 컴파일러를 통해 타입 선언이 생성된 경우라면 버전 불일치 문제를 해결하기는 한다.
- 그러나 번들링 방식은 부수적인 네 가지 문제점을 가지고 있다.

    <br>

  **✔️ 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했지만 타입스크립트 버전이 올라가면서 오류가 발생하는 경우에 문제**

  - @types을 별도로 사용하는 경우라면 라이브러리 자체의 버전에 맞추어 선택할 수 있다.
  - 그러나 번들된 타입에서는 @types의 버전 선택이 불가능하다.
  - 단 하나의 잘못된 타입 선언으로 인해 타입스키립트의 버전을 올리지 못하는 불상사가 생길 수 있는 것이다.
  - 번들된 타입과 DefinitelyTyped이 비교되는 부분이다.
  - 마이크로소프트는 타입스크립트 버전이 올라감에 따라 DefinitelyTyped의 모든 타입 선언을 점검하며, 문제가 발견된 곳은 빠른 시간 내에 해결하고 있다.

  <br>

  **✔️ 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존한다면 문제**

  - 보통은 의존성이 devDependencies에 들어간다.
  - 그러나 프로젝트를 공개하여 다른 사용자가 설치하게 되면 devDependencies가 설치되지 않을 것이고 타입 오류가 발생하게 된다.
  - 반면 자바스크립트 사용자 입장에서는 @types를 설치할 이유가 없기 때문에 dependencies에 포함하고 싶지 않을 것이다.
  - 아이템51에서는 이러한 상황에 대한 표준 해결책을 다룬다.
  - 한편 DefinitelyTyped에 타입 선언을 공개하는 경우라면 첫 번째 상황은 전혀 문제가 되지 않는다.
  - 타입 선언은 @types에 있을 것이고 타입스크립트 사용자만이 타입 정보를 사용하게 된다.

  <br>

  **✔️ 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우에는 과거 버전으로 돌아가서 패치 업데이트를 해야 한다.**

  - 번들링된 타입 선언에서는 어려운 일이지만, DefinitelyTyped는 동일 라이브러리의 여러 버전의 타입 선언을 동시에 유지보수할 수 있는 메커니즘을 가지고 있다.

  <br>

  **✔️ 타입 선언의 패치 업데이트를 자주 하기 어렵다는 문제**

  - DefinitelyTyped는 커뮤니티에서 관리되기 때문에 담장자가 5일 이내에 패치를 적용하지 않는 것으로 보인다면, 전체 유지보수 담당자가 패치를 하게 된다.
  - 그러나 개별 프로젝트에서는 비슷한 처리 시간을 보장하기 어렵다.

<br>

- 타입스크립트에서 의존성을 관리한다는 것은 쉽지 않은 일지만, 잘 관리한다면 그에 따른 보상이 함께 존재한다.
- 잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되며 생산성 역시 크게 향상시킬 수 있다.
- 만약 의존성 관리에 문제가 생긴다면 이번 아이템의 처음에 언급했던 세 가지 버전을 기억해야 한다.

<br>

- 라이브러리를 공개하려는 경우, 타입 선언을 자체적으로 포함하는 것과 타입 정보만 분리하여 DefinitelyTyped에 공개하는 것의 장단점을 비교해 봐야 한다.
- 공식적인 권장사항은 라이브러리가 타입스크립트로 작성된 경우만 타입 선언을 라이브러리에 포함하는 것이다.
- 실제로 타입스크립트 컴파일러가 타입 선언을 대신 생성해 주기 때문에, 타입스크립트로 작성된 라이브러리에 타입 선언을 포함하는 방식은 잘 동작한다.
- 자바스크립트로 작성된 라이브러리라면 손수 작성한 타입 선언은 오류가 있을 가능성이 높고 잦은 업데이트가 필요하게 된다.
- 자바스크립트로 작성된 라이브러리는 타입 선언을 DefinitelyTyped에 공개하여 커뮤니티에서 관리하고 유지보수하도록 맡기는 것이 좋다.
