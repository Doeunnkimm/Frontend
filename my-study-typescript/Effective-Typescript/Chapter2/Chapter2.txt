🌊 2장 타입스크립트의 타입 시스템

타입스크립트는 '코드를 자바스크립트로 변환'하는 역할도 하지만,

    가장 중요한 역할은 🔥'타입 시스템'🔥

    1. 편집기를 사용하여 타입 시스템 탐색하기

        타입스크립트를 설치하면 실행할 수 있는 2가지
            1) 타입스크립트 컴파일러(tsc)
            2) 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

        보통은 타입스크립트 컴파일러(tsc)를 실행하는 것이 주목적
        그렇지만, 타입스크립트 서버 또한 '언어 서비스'를 제공한다는 점에서 중요 !
                                         -------------------

        언어 서비스 ?
            코드 자동 완성, 명세(사양) 검사, 검색, 리팩터링이 포함

        보통은 편집기를 통해서 언어 서비스를 사용하는데, 타입스크립트 서버에서 언어 서비스를 제공하도록 설정하는 것이 좋음
        -> 유용한 기능이니 꼭 사용하자

        보통의 경우, 심벌 위에 마우스 커서를 대면 타입스크립트가 그 타입을 어떻게 판단하고 있는지 확인할 수 있다.

            let num = 10;
            --> num 변수의 타입을 number라고 직접 지정하지는 않았지만, 타입스크립트는 10이라는 값을 보고 그 타입을 알아낸다.

        
        * 특정 시점에 타입스크립트가 값의 타입을 어떻게 이해하고 있는지 살펴보는 것은
          타입 넓히기와 좁히기의 개념을 잡기 위해 꼭 필요한 과정

          --> 조건문의 분기에서 값의 타입이 어떻게 변하는지 살펴보는 것은 시스템을 연마하는 매우 좋은 방법 !

            function logMessage(message: string | null) {
                if (message) {
                    // message: string  추론
                }
            }

        * 편집기상의 오류를 살펴보는 것도 타입 시스템의 성향을 파악하는 데 좋은 방법 !

        * 언어 서비스는 라이브러리와 라이브러리의 타입 선언을 탐색할 때 도움이 된다.
          ==> 라이브러리의 객체들을 ctrl+click하게 되면 나오는 타입들 보기 !

          ==> 많은 타입들을 탐색하다 보면,
              처음에는 이해하기 어렵지만, 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링 되었는지,
              어떻게 오류를 찾아낼지 살펴볼 수 있다.

----------------------------------------------------------------------------------------------------------------------------------------

    2. 타입이 값들의 집합이라고 생각하기
        런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다.
        변수에는 다음처럼 다양한 종류의 값을 할당할 수 있다.

            42
            null
            undefined
            'Canada'
            { animal: 'Whale', weight_lbs: 40_000 }
            /regex/
            new HTMLButtonElement
            (x, y) => x + y

        그러나 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 '타입'을 가지고 있다.

        🟢 타입 = 할당 가능한 값들의 집합 = 범위 🟢

            1) 가장 작은 집합 --> 아무 값도 포함하지 않는 공집합 --> never 타입
                never 타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 X

            2) 그 다음으로 작은 집합은 한 가지 값만 포함하는 타입 --> unit 타입이라고 불리는 literal 타입

        ✨ 타입 체커의 역할은 !!
            하나의 집합이 다른 집합의 부분 집합인지 검사하는 것 !

        ✨ 타입스크립트 타입이 되지 못하는 값의 집합들이 있다.
            정수에 대한 타입, 또는 x와 y 속성 외에 다른 속성이 없는 객체는 타입스크립트 타입에 존재 x

        ✨✨ 'A는 B를 상속' =  'A는 B에 할당 가능' =  'A는 B의 서브타입' = 'A는 B의 부분집합'

-----------------------------------------------------------------------------------------------------------------

    3. 타입 공간과 값 공간의 심벌 구분하기

        타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중의 한 곳에 존재
                                     --------------------------------------
        심벌은 이름이 같더라도, 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있음

            interface Cylinder {
                      --------
                radius: number;
                height: number;
            }

            const Cylinder = ( radius: number, height: number ) => ({ radius, height });
                  --------

            ==> interface Cylinder에서 Cylinder는 타입으로 쓰인다.
                Cylinder에서 Cylinder와 이름은 같지만 값으로 쓰이며, 서로 관련도 없다....
            
            ==> 상황에 따라서 Cylinder는 타입으로 쓰일 수 있고, 값으로 쓰일 수도 있다.

            그런데 다음과 같은 점이 오류를 야기하기도...

                function calculateVolume(shape: unknown) {
                    if(shape instanceof Cylinder) {
                        shape.radius // '{}' 형식에 'radius' 속성이 없습니다.
                    }
                }

                ==> 오류를 살펴보자

                    아마도 instanceof를 이용해 shape가 Cylinder 타입인지 체크하려고 했을 것
                    그러나 instanceof는 자바스크립트 런타임 연산자이고, 값에 대해서 연산을 한다.
                    그래서 instnaceof Cylinder는 타입이 아니라 함수를 참조한다.
                                                 ------------------------

            🟢 한 심벌이 타입인지 값인지는 언뜻 봐서는 알 수 없다.
              => 어떤 형태로 쓰이는지 문맥을 살펴 알아내야 한다.

              type T1 = 'string literal';
              type T2 = 123;
              const v1 = 'string literal';
              const v2 = 123;

              일반적으로 type이나 interface 다음에 나오는 심벌은 타입인 반면, const나 let 선언에 쓰이는 것은 값 !

            🟢 두 공간에 대한 개념을 잡으려면 '타입스크립트 플레이그라운드'를 활용해보자
              
              플레이 그라운드
                - 타입스크립트 소스로부터 변환된 자바스크립트 결과물을 보여준다.
                - 컴파일 과정에서 타입 정보는 제거되기 때문에, 심벌이 사라진다면 그것은 타입에 해당될 것 !

            🟢 타입스크립트 코드에서 타입과 값은 번갈아 나올 수 있다.
              타입 선언(:) 또는 단언문(as) 다음에 나오는 심벌은 타입인 반면, = 다음에 나오는 모든 것은 값이다.

            🟢 class와 enum은 상황에 따라 타입과 값 두 가지 모두 가능한 예약어이다.

            🟢 typeof는 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 한다.
                         -----------------------------------------

                type T1 = typeof p; // 타입은 Person
                type T2 = typeof email;
                    // 타입은 (p: Person, subject: string, body: string) => Response

                const v1 = typeof p; // 값은 "object"
                const v2 = typeof email; // 값은 "function"

                - 타입의 관점에서, typeof는 값을 읽어서 타입스크립트 타입을 반환
                - 값의 관점에서, typeof는 자바스크립트 런타임의 typeof 연산자가 된다.
                    - 심벌의 런타임 타입을 가리키는 문자열을 반환

            🟢 타입스크립트 타입의 종류가 무수히 많은 반면,
                자바스크립트에는 과거부터 지금까지 단 6개
                    - string
                    - number
                    - boolean
                    - undefined
                    - object
                    - function

            🟢 class 키워드는 값과 타입 두 가지로 모두 사용된다.
                따라서 클래스에 대한 typeof는 상황에 따라 다르게 동작한다.

                class Cylinder {
                    radius=1;
                    height=1;
                }

                const v = typeof Cylinder; // 값이 'function'
                type T = typeof Cylinder; // 타입이 typeof Cylinder

                * 여기서 중요한 것은 Cylinder가 인스턴스의 타입이 아니라는 점 !
                    실제로는 new 키워드를 사용할 때 볼 수 있는 생성자 함수

                declare let fn: T;
                const c = new fn(); // 타입이 Cylinder

                * 다음 코드처럼 InstanceType 제네릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있음

                    type C = InstanceType<typeof Cylinder>; // 타입이 Cylinder

            🟢 속성 접근자인 []는 타입으로 쓰일 때에도 동일하게 동작한다.
                그러나 obj['field']와 obj.field는 값이 동일하더라도 타입은 다를 수 있다.
                따라서 타입의 속성을 얻을 때에는 반드시 첫 번째 방법(obj['field'])를 사용해야 한다.

                    const first: Person['first'] = p['first']; // 또는 p.first
                          ---값  ------------타입  -------값

                    type PersonEl = Person['first' | 'last']; // 타입은 string
                    type Tuple = [string, number, Date];
                    type TupleEl = Tuple[number]; // 타입은 string | number | Date

            🟢 두 공간 사이에서 다른 의미를 가지는 코드 패턴들이 있다

                - 값으로 쓰이는 this는 자바스크립트의 this 키워드이다.
                  타입으로 쓰이는 this는, 일명 '다형성(polymorphic) this'라고 불리는 this의 타입스크립트 타입이다.
                
                - 값에서 &와 |는 AND와 OR 비트연산이다.
                  타입에서는 인터섹션과 유니온이다.

                - const는 새 변수를 선언하지마, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꾼다.

                - extends는 서브 클래스(class A extends B) 또는 서브 타입(interface A extends B) 또는
                  제너릭 타입의 한정자(Generic<T extends number>)를 정의할 수 있다

                - in은 루프(for (key in object)) 또는 매핑된(mapped) 타입에 등장한다

                ==> 타입스크립트 코드가 잘 동작하지 않는다면
                    타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 크다.

                    예를 들어, 단일 객체 매개변수를 받도록 email 함수를 변경했다고 생각해보자

                        function email(options: { person: Person, subject: string, body: string }) {
                            // ...
                        }

                        자바스크립트에서는 객체 내의 각 속성을 로컬 변수로 만들어 주는 구조 분해(destructuring) 할당을 사용할 수 있다.

                        function email({person, subject, body}) { ... }

                        🔴 그런데 타입스크립트에서 구조 분해 할당을 하면, 이상한 오류가 발생한다.

                            function email({
                                person: Person, // 바인딩 요소 'Person'에 암시적으로 'any' 형식이 있습니다
                                subject: string,
                                body: string,
                            })

                            ✨ 값의 관점에서 Person과 string이 해석되었기 때문에 오류가 발생했다.
                                문제를 해결하려면 타입과 값을 구분해야 한다.

                                function email(
                                    {person, subject, body}: {person: Person, subject: string, body: string}
                                ) {
                                    // ...
                                }

                                ==> 이 코드는 장황하긴 하지만,
                                    매개변수에 명명된 타입을 사용하거나 문맥에서 추론되도록 잘 동작한다.

-----------------------------------------------------------------------------------------------------------------

    4. 타입 단언보다는 타입 선언을 사용하기

        타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 2가지 !

            interface Person { name: string }

            const alice: Person = { name: 'Alice' }; // 타입은 Person
            const bob: { name: 'Bob' } as Person; // 타입은 Person

        🔴 이 두 가지 방법은 결과가 같아 보이지만 그렇지 않다 !

            첫 번째 alice: Person은 변수에 '타입 선언'을 붙여서 그 값이 선언된 타입임을 명시한다.
            두 번째 as Person은 '타입 단언'을 수행한다. 그러면 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.

            ✨ 타입 단어(as Person)보다 타입 선언(:Person)을 사용하는 게 낫다.

                    const alice: Person = {}; // 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.
                    const bob = {} as Person; // 오류 없음

                    ==> 타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.
                        타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.

            ✨ 타입 선언과 단언의 차이는 속성을 추가할 때도 마찬가지

                const alice: Person {
                    name: 'Alice',
                    occupation: 'TypeScript developer', // 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Person' 형식에 'occupation'이(가) 없습니다.
                };

                const bob = {
                    name: 'Bob',
                    occupation: 'JavaScript developer'
                } as Person; // 오류 없음

            ✨ 타입 단언이 꼭 필요한 경우가 아니라면, 안전성 체크도 되는 타입 선언을 사용하는 것이 좋다.
                                                      ----------------------------------
                🏷️ 아마 const bob = <Person>{} 같은 코드를 본 적이 있을텐데, 이 코드는 단언문의 원래 문법이며 {} as Person과 동일
                    그러나 const bob = <person>{} 같은 코드는 <Person>이 .tsc(타입스크립트 + 리액트)에서 컴포넌트 태그로 인식되기 때문에 현재는 잘 쓰이지 않는다.

               * 화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있다.

                    예를 들어, 다음 코드에서 Person 인터페이스를 사용하고 싶다고 가정해보자

                        const people = ['alice', 'bob', 'jan'].map(name => ({ name }));
                        // Person[]을 원했지만 결과는 { name: string; }[]...

                        {name}에 타입 단언을 쓰면 문제가 해결되는 것처럼 보인다.
                        ---> const people = ['alice', 'bob', 'jan'].map(name => ({ name } as Person)); // 타입은 Person[]

                        🔴 그러나 타입 단언을 사용하면 런타임에 문제가 발생

                            const people = ['alice', 'bob', 'jan'].map(name => ({} as Person)); // 오류 없음

                        🟢 단언문을 쓰지 않고, 다음과 같이 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적

                                const people = ['alice', 'bob', 'jan'].map(name => {
                                    const person: Person = { name };
                                    return person;
                                }); // 타입은 Person[]

                            그러나 원래 코드에 비해 꽤나 번잡해 보인다. 좀 더 간결하게 하면 다음과 같다.

                                const people = ['alice', 'bob', 'jan'].map((name): Person => ({ name })); // 타입은 Person[]

                            (name): Person은 name의 타입이 없고, 반환 타입이 Person이라고 명시.
                            그러나 (name: Person)은 name의 타입이 Person임을 명시하고 반환 타입은 없기 때문에 오류가 발생

                            ✨ 다음 코드는 최종적으로 원하는 타입을 명시하고, 타입스크립트가 할당문의 유효성을 검사하게 한다.

                                const people: Person[] = ['alice', 'bob', 'jan'].map((name): Person => ({ name }));

                        🟢 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 한다.

            ✨ 타입 단언이 꼭 필요한 경우

                타입 단언은 타입 체커가 추론한 타입보다 내가 판단하는 타입이 더 정확할 때 의미가 있다.

                1) 예를 들어, DOM 엘리먼트에 대해서는 타입스크립트보다 개발자가 더 잘 알고 있을 것이다.

                    document.querySelector('#myButton').addEventListener('click', e => {
                        e.currentTarget // 타입은 EventTarget
                        const button = e.currentTarget as HTMLButtonElement;
                        button // 타입은 HTMLButtonElement
                    });

                    타입스크립트는 DOM에 접근할 수 없기 때문에 #myButton이 버튼 엘리먼트인지 알지 못한다.
                    그리고 이벤트의 currentTarget이 같은 버튼이어야 하는 것도 알지 못한다.
                    
                    우리는 타입스크립트가 알지 못하는 정보를 가지고 있기 때문에 여기서는 타입 단언문을 쓰는 것이 타당하다.

                2) 자주 쓰이는 특별한 문법(!)을 사용해서 null이 아님을 단언하는 경우도 있다.

                    const elNull = document.getElementById('foo'); // 타입은 HTMLElement | null
                    const el = document.getElementById('foo'); // 타입은 HTMLElement

                    변수의 접두사로 쓰인 !는 boolean의 부정문이다. ex. const [isOpen, setIsOpen] = useState(false); , setIsOpen(prev => !prev)
                    
                    🟢 그러나 접미사로 쓰인 !는 그 값이 null이 아니라는 단언문으로 해석된다.
                        => 단언문은 컴파일 과정 중에 제거되므로, 타입 체커는 알지 못하지만 그 값이 null이 아니라고 확신할 수 있을 때 사용해야 한다.
                           만약 확신할 수 있는 상황까지는 아니라면, null인 경우를 체크하는 조건문을 사용해야 한다.

                3) 타입 단언문으로 임의의 타입 간에 변환을 할 수는 없다. A가 B의 부분집합인 경우에 타입 단언문을 사용해 변환할 수 있다.

                    HTMLElement는 HTMLElement | null의 서브타입이기 때문에 이러한 타입 단언은 동작한다.
                    HTMLButtonElement는 EventTarget의 서브타입이기 때문에 역시 동작한다.
                    그리고 Person은 {}dml 서브타입이므로 동작한다.
                    
                    그러나 Person과 HTMLElement는 서로의 서브타입이 아니기 때문에 변환이 불가능

                    interface Person { name: string; }
                    const body = document.body;
                    const el = body as Person;
                        // ~~~~~~~~~~~~~~~~~~~ 'HTMLElement' 형식을 'Person' 형식으로 변환하는 것은
                                                형식이 다른 형식과 충분히 겹치지 않기 때문에
                                                실수일 수 있습니다. 이것이 의도적인 경우에는
                                                먼저 식을 'unknown'으로 변환하십시오.

                    이 오류를 해결하려면 unknown타입을 사용해야 한다.
                    모든 타입은 unknown의 서브타입이기 때문에 unknown이 포함된 단언문은 항상 동작한다.
                    unknown 단언은 임의의 타입 간에 변환을 가능케 하짐나, unknown을 사용한 이상 적어도 무언가 위함한 동작......

                    const el = document.body as unknown as Person; // 정상

-----------------------------------------------------------------------------------------------------------------------------------------------------------




                
        
        

         

