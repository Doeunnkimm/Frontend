🌊 2장 타입스크립트의 타입 시스템

타입스크립트는 '코드를 자바스크립트로 변환'하는 역할도 하지만,

    가장 중요한 역할은 🔥'타입 시스템'🔥

    1. 편집기를 사용하여 타입 시스템 탐색하기

        타입스크립트를 설치하면 실행할 수 있는 2가지
            1) 타입스크립트 컴파일러(tsc)
            2) 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

        보통은 타입스크립트 컴파일러(tsc)를 실행하는 것이 주목적
        그렇지만, 타입스크립트 서버 또한 '언어 서비스'를 제공한다는 점에서 중요 !
                                         -------------------

        언어 서비스 ?
            코드 자동 완성, 명세(사양) 검사, 검색, 리팩터링이 포함

        보통은 편집기를 통해서 언어 서비스를 사용하는데, 타입스크립트 서버에서 언어 서비스를 제공하도록 설정하는 것이 좋음
        -> 유용한 기능이니 꼭 사용하자

        보통의 경우, 심벌 위에 마우스 커서를 대면 타입스크립트가 그 타입을 어떻게 판단하고 있는지 확인할 수 있다.

            let num = 10;
            --> num 변수의 타입을 number라고 직접 지정하지는 않았지만, 타입스크립트는 10이라는 값을 보고 그 타입을 알아낸다.

        
        * 특정 시점에 타입스크립트가 값의 타입을 어떻게 이해하고 있는지 살펴보는 것은
          타입 넓히기와 좁히기의 개념을 잡기 위해 꼭 필요한 과정

          --> 조건문의 분기에서 값의 타입이 어떻게 변하는지 살펴보는 것은 시스템을 연마하는 매우 좋은 방법 !

            function logMessage(message: string | null) {
                if (message) {
                    // message: string  추론
                }
            }

        * 편집기상의 오류를 살펴보는 것도 타입 시스템의 성향을 파악하는 데 좋은 방법 !

        * 언어 서비스는 라이브러리와 라이브러리의 타입 선언을 탐색할 때 도움이 된다.
          ==> 라이브러리의 객체들을 ctrl+click하게 되면 나오는 타입들 보기 !

          ==> 많은 타입들을 탐색하다 보면,
              처음에는 이해하기 어렵지만, 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링 되었는지,
              어떻게 오류를 찾아낼지 살펴볼 수 있다.

----------------------------------------------------------------------------------------------------------------------------------------

    2. 타입이 값들의 집합이라고 생각하기
        런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다.
        변수에는 다음처럼 다양한 종류의 값을 할당할 수 있다.

            42
            null
            undefined
            'Canada'
            { animal: 'Whale', weight_lbs: 40_000 }
            /regex/
            new HTMLButtonElement
            (x, y) => x + y

        그러나 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 '타입'을 가지고 있다.

        🟢 타입 = 할당 가능한 값들의 집합 = 범위 🟢

            1) 가장 작은 집합 --> 아무 값도 포함하지 않는 공집합 --> never 타입
                never 타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 X

            2) 그 다음으로 작은 집합은 한 가지 값만 포함하는 타입 --> unit 타입이라고 불리는 literal 타입

        ✨ 타입 체커의 역할은 !!
            하나의 집합이 다른 집합의 부분 집합인지 검사하는 것 !

        ✨ 타입스크립트 타입이 되지 못하는 값의 집합들이 있다.
            정수에 대한 타입, 또는 x와 y 속성 외에 다른 속성이 없는 객체는 타입스크립트 타입에 존재 x

        ✨✨ 'A는 B를 상속' =  'A는 B에 할당 가능' =  'A는 B의 서브타입' = 'A는 B의 부분집합'

-----------------------------------------------------------------------------------------------------------------

    3. 타입 공간과 값 공간의 심벌 구분하기

        타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중의 한 곳에 존재
                                     --------------------------------------
        심벌은 이름이 같더라도, 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있음

            interface Cylinder {
                      --------
                radius: number;
                height: number;
            }

            const Cylinder = ( radius: number, height: number ) => ({ radius, height });
                  --------

            ==> interface Cylinder에서 Cylinder는 타입으로 쓰인다.
                Cylinder에서 Cylinder와 이름은 같지만 값으로 쓰이며, 서로 관련도 없다....
            
            ==> 상황에 따라서 Cylinder는 타입으로 쓰일 수 있고, 값으로 쓰일 수도 있다.

            그런데 다음과 같은 점이 오류를 야기하기도...

                function calculateVolume(shape: unknown) {
                    if(shape instanceof Cylinder) {
                        shape.radius // '{}' 형식에 'radius' 속성이 없습니다.
                    }
                }

                ==> 오류를 살펴보자

                    아마도 instanceof를 이용해 shape가 Cylinder 타입인지 체크하려고 했을 것
                    그러나 instanceof는 자바스크립트 런타임 연산자이고, 값에 대해서 연산을 한다.
                    그래서 instnaceof Cylinder는 타입이 아니라 함수를 참조한다.
                                                 ------------------------

            🟢 한 심벌이 타입인지 값인지는 언뜻 봐서는 알 수 없다.
              => 어떤 형태로 쓰이는지 문맥을 살펴 알아내야 한다.

              type T1 = 'string literal';
              type T2 = 123;
              const v1 = 'string literal';
              const v2 = 123;

              일반적으로 type이나 interface 다음에 나오는 심벌은 타입인 반면, const나 let 선언에 쓰이는 것은 값 !

            🟢 두 공간에 대한 개념을 잡으려면 '타입스크립트 플레이그라운드'를 활용해보자
              
              플레이 그라운드
                - 타입스크립트 소스로부터 변환된 자바스크립트 결과물을 보여준다.
                - 컴파일 과정에서 타입 정보는 제거되기 때문에, 심벌이 사라진다면 그것은 타입에 해당될 것 !

            🟢 타입스크립트 코드에서 타입과 값은 번갈아 나올 수 있다.
              타입 선언(:) 또는 단언문(as) 다음에 나오는 심벌은 타입인 반면, = 다음에 나오는 모든 것은 값이다.

            🟢 class와 enum은 상황에 따라 타입과 값 두 가지 모두 가능한 예약어이다.

            🟢 typeof는 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 한다.
                         -----------------------------------------

                type T1 = typeof p; // 타입은 Person
                type T2 = typeof email;
                    // 타입은 (p: Person, subject: string, body: string) => Response

                const v1 = typeof p; // 값은 "object"
                const v2 = typeof email; // 값은 "function"

                - 타입의 관점에서, typeof는 값을 읽어서 타입스크립트 타입을 반환
                - 값의 관점에서, typeof는 자바스크립트 런타임의 typeof 연산자가 된다.
                    - 심벌의 런타임 타입을 가리키는 문자열을 반환

            🟢 타입스크립트 타입의 종류가 무수히 많은 반면,
                자바스크립트에는 과거부터 지금까지 단 6개
                    - string
                    - number
                    - boolean
                    - undefined
                    - object
                    - function

            🟢 class 키워드는 값과 타입 두 가지로 모두 사용된다.
                따라서 클래스에 대한 typeof는 상황에 따라 다르게 동작한다.

                class Cylinder {
                    radius=1;
                    height=1;
                }

                const v = typeof Cylinder; // 값이 'function'
                type T = typeof Cylinder; // 타입이 typeof Cylinder

                * 여기서 중요한 것은 Cylinder가 인스턴스의 타입이 아니라는 점 !
                    실제로는 new 키워드를 사용할 때 볼 수 있는 생성자 함수

                declare let fn: T;
                const c = new fn(); // 타입이 Cylinder

                * 다음 코드처럼 InstanceType 제네릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있음

                    type C = InstanceType<typeof Cylinder>; // 타입이 Cylinder

            🟢 속성 접근자인 []는 타입으로 쓰일 때에도 동일하게 동작한다.
                그러나 obj['field']와 obj.field는 값이 동일하더라도 타입은 다를 수 있다.
                따라서 타입의 속성을 얻을 때에는 반드시 첫 번째 방법(obj['field'])를 사용해야 한다.

                    const first: Person['first'] = p['first']; // 또는 p.first
                          ---값  ------------타입  -------값

                    type PersonEl = Person['first' | 'last']; // 타입은 string
                    type Tuple = [string, number, Date];
                    type TupleEl = Tuple[number]; // 타입은 string | number | Date

            🟢 두 공간 사이에서 다른 의미를 가지는 코드 패턴들이 있다

                - 값으로 쓰이는 this는 자바스크립트의 this 키워드이다.
                  타입으로 쓰이는 this는, 일명 '다형성(polymorphic) this'라고 불리는 this의 타입스크립트 타입이다.
                
                - 값에서 &와 |는 AND와 OR 비트연산이다.
                  타입에서는 인터섹션과 유니온이다.

                - const는 새 변수를 선언하지마, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꾼다.

                - extends는 서브 클래스(class A extends B) 또는 서브 타입(interface A extends B) 또는
                  제너릭 타입의 한정자(Generic<T extends number>)를 정의할 수 있다

                - in은 루프(for (key in object)) 또는 매핑된(mapped) 타입에 등장한다

                ==> 타입스크립트 코드가 잘 동작하지 않는다면
                    타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 크다.

                    예를 들어, 단일 객체 매개변수를 받도록 email 함수를 변경했다고 생각해보자

                        function email(options: { person: Person, subject: string, body: string }) {
                            // ...
                        }

                        자바스크립트에서는 객체 내의 각 속성을 로컬 변수로 만들어 주는 구조 분해(destructuring) 할당을 사용할 수 있다.

                        function email({person, subject, body}) { ... }

                        🔴 그런데 타입스크립트에서 구조 분해 할당을 하면, 이상한 오류가 발생한다.

                            function email({
                                person: Person, // 바인딩 요소 'Person'에 암시적으로 'any' 형식이 있습니다
                                subject: string,
                                body: string,
                            })

                            ✨ 값의 관점에서 Person과 string이 해석되었기 때문에 오류가 발생했다.
                                문제를 해결하려면 타입과 값을 구분해야 한다.

                                function email(
                                    {person, subject, body}: {person: Person, subject: string, body: string}
                                ) {
                                    // ...
                                }

                                ==> 이 코드는 장황하긴 하지만,
                                    매개변수에 명명된 타입을 사용하거나 문맥에서 추론되도록 잘 동작한다.

-----------------------------------------------------------------------------------------------------------------



                
        
        

         

