🚀 1장 타입스크립트 알아보기
-----------------------------------------------------------------------------------------------------------

1. 타입스크립트와 자바스크립트의 관계 이해하기

    * 관계 : 자바스크립트는 타입스크립트의 부분 집합 
        => 타입스크립트 > 자바스크립트

    * 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것
        => 타입 구문을 추가함으로써
           코드의 '의도'가 무엇인지 타입 구문을 통해 타입스크립트에게 알려줄 수 있기 때문에
           코드의 동작과 의도가 다른 부분을 찾을 수 있다

    * 타입스크립트의 도움을 받으면 오류가 적은 코드를 작성할 수 있다
        => ex. null + 7, [] + 12, ...

    * 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있다
        => 런타임 오류를 발생시키는 코드를 찾아내려고 한다
        => 기본적인 타입스크립트 기능만으로는 모든 타입 오류를 무조건 다 찾지는 못할 수 있다


-----------------------------------------------------------------------------------------------------------

2. 타입스크립트 설정 이해하기

    * 가급적 tsconfig.json 설정 파일을 사용하는 것이 좋음
        => 타입스크립트를 어떻게 사용할 계획인지 동료들이나 다른 도구들이 알 수 있음

        $ tsc --init

    
    {
        "compilerOptions": {
            "noImplicitAny": true, // 코드를 무조건 명시해라 (any라고 하더라도)
            "strictNullCheck": true, // null과 undefined를 허용 X
        }
    }
        => 타입스크립트는 타입 정보를 가질 때 가장 효과적 !
        => 되도록이면 설정하자 ***
        => 타입스크립트가 문제를 발견하기 수월해지고, 코드의 가독성 좋아지고, 개발자의 생산성도 향상

        => 이 모든 설정을 하고 싶다면 strict 설정을 하면 됨 => 대부분의 오류를 잡아낼 수 있음
        => 오류를 잡아내는 데 많은 도움이 되지만, 코드 작성을 어렵게 하기도 한다

    * any 타입을 매개변수에 사용하면 타입 체커는 무력해짐
        -> 매우 유용하지만 주의해서 사용해야 함

    🟡 타입스크립트 프로젝트를 시작했을 때 tsconfig.json 파일 설정을 통해 보다 타입을 얼마나 엄격하게 지킬 것인지
        꼼꼼하게 여러 설정을 통해 정하고 시작하도록 하자

------------------------------------------------------------------------------------------------------------

3. 코드 생성과 타입이 관계없음을 이해하기

    타입스크립트 컴파일러의 두 가지 역할

        (1) 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일(transpile)
        (2) 코드의 타입 오류를 체크

        ※ 두 가지가 서로 완벽히 독립적
            => 타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향 X
            => 자바스크립트의 실행 시점에도 타입은 영향 X

    ✨ 타입스크립트가 할 수 있는 일과 할 수 없는 일

        🟢 타입 오류가 있는 코드도 컴파일이 가능

            -> 컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능
            -> 문제가 될 만한 부분을 알려주지만, 그렇다고 빌드를 멈추지는 X

            참고) C나 자바는 타입체크와 컴파일이 동시에 이루어져 오류가 있을 경우 빌드를 멈춤

            참고) 만약 오류가 있을 때 컴파일하지 않도록 하려면,

                tsconfig.json -> noEmitOnError: true 설정

        🔴 런타임에는 타입 체크가 불가능

            자바스크립트가 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버림

            * 런타임 시 타입 정보를 유지하는 방법

                (1) 해당 속성이 있는 지를 체크해보기

                    ex) const calculateArea(shape: Shape) {
                            if('height' in shape) {
                                shape; // 타입이 Rectangle
                                return shape.width * shape.height
                            }
                        }

                    => 속성 체크는 런타임에 접근 가능한 값에만 관련되지만, 
                       타입 체커 역시도 shape의 타입을 Rectangle로 보정해 주기 때문에 오류가 사라짐

                (2) '태그' 기법

                    ex) const calculateArea = (shape: Shape) => {
                            if (shape.kind === 'rectangle') {
                                return shape.width * shape.height;
                            } else {
                                return shape.width * shape.width;
                            }
                        };
                      
        🔴 타입 연산은 런타임에 영향을 주지 X

            ex) const asNumber = (val: number | string): number => {
                    return val as number;
                };

                위 함수를 자바스크립트로 변환하면

                function asNumber(val) {
                    return val
                }

                -> 코드에 아무런 정제 과정 X
                -> as Number는 타입 연산이고 런타임 동작에는 아무런 양향 X
                => 값을 정제하기 위한 목적으로 타입 연산을 사용하는 것은 의미 X

                따라서 아래와 같이 타입을 체크하는 방법이 적절

                function asNumber(val: number | string): number {
                    return typeof(val) === 'string' ? Number(val) : val;
                }

        🔴 런타임 타입은 선언된 타입과 다를 수 있다

            * 타입스크립트는 죽은(dead) 코드(실행되지 못하는)를 찾아내지만, 

                function setLightSwitch(value: boolean) {
                    switch (value) {
                        case true:
                        turnLightOn();
                        break;
                        case false:
                        turnLightOff();
                        break;
                        default:
                        console.log('실행되지 않았음');
                    }
                }

                위 코드에서는 strict를 설정하더라도 찾아내지 못함. 그러면 마지막 부분을 실행할 수 있는 경우는 무엇일까 ?

                    : boolean이 타입 선언문이라는 것에 주목

                     => 타입스크립트의 타입이기 때문에 : boolean은 런타임에 제거됨
                     => 자바스크립트라면 실수로 setLightSwitch("ON")으로 호출할 수도 있을 것

                interface LightApiResponse {
                        lightSwitchValue: boolean;
                    }

                    async function setLight() {
                    const response = await fetch('/light');
                    const result: LightApiResponse = await response.json();
                    setLightSwitch(result.lightSwitchValue);
                }

                    /light를 요청하면 그 결과로 LightApiResponse를 반환하라고 선언했지만,
                    실제로 그렇게 되리라는 보장은 없음

                    API를 잘못 파악해서 lightSwitchValue가 실제로는 문자열이었다면?
                        -> 런타임에는 setLightSwitch 함수까지 전달될 것

                    => 타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있다
                    그렇지만, 타입이 달라지는 혼란스러운 상황을 가능한 한 피해야 할 것

                    * 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 한다


        🔴 타입스크립트 타입으로는 함수를 오버로드할 수 없다

            C++ 같은 언어는 동일한 이름에 매개변수만 다른 여러 버전의 함수를 허용 -> 함수 오버로딩 허용

            그러나 타입스크립트는 타입과 런타임의 동작이 무관하기 때문에 함수 오버로딩 X
                                 ---------------------------            
            * 타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 온전히 타입 수준에서만 동작한다
              하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만, 구현체(implementation)은 오직 하나뿐


        🟢 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

            타입과 타입 연산자는 자바스크립트 변환 시점에 제거 -> 런타임에 아무런 영향 X

            ** 타입스크립트의 정적 타입은 실제로 비용이 전혀 X

-----------------------------------------------------------------------------------------------------------------------

4. 구조적 타이핑에 익숙해지기
