## 단위 테스트 대상 선정하기

**쇼핑몰 예제 프로젝트의 단위 테스트 전략**

- state나 로직처리 없이 UI만 그리는 컴포넌트는 검증하지 않는다.
- 해당 검증은 스토리북과 같은 도구를 통해 검증
- 간단한 로직 처리만 하는 컴포넌트는 상위 컴포넌트의 통합 테스트에서 검증한다.
- 공통 유틸 함수는 단위 테스트로 검증한다.
- 다른 모듈과의 의존성이 없다.
- 여러 곳에서 사용되기 때문에 검증을 통해 안정성을 높인다.

## 모듈 모킹(Mocking)

**모킹**

- 실제 모듈/객체와 동일한 동작을 하도록 만든 모의 모듈/객체(Mock)로 실제를 대체하는 것
- `vi.mock()`을 사용해 특정 모듈을 모킹할 수 있다.
- 외부 모듈의 검증은 완전히 배제하고, 대상이 되는 컴포넌트의 테스트만 독립적으로 작성할 수 있다.
- 단, 외부 모듈 역시 별도로 검증되어야 한다.

**모킹 초기화**

- 각 테스트의 독립성과 안정성을 보장하기 위해 `teardown`에서 모킹을 초기화 하자
- vitest의 `resetAllMocks`, `clearAllMocks`, `restoreAllMocks`를 활용해 초기화 하자

## 리액트 훅 테스트(feat. act함수)

**리액트 훅**

- 리액트 렌더링 매커니즘을 따른 단순 함수이기 때문에 독립적인 단위 테스트를 작성하기 적합함
- React Testing Library의 renderHook API를 사용해 편하게 검증할 수 있음

**act()**

- 상호 작용(렌더링, 이펙트 등..)을 함께 그룹화하고 실행하여 실제 앱에서 동작하는 것처럼 렌더링과 업데이트 상태를 반영하도록 도와줌
- 테스트 환경에서 컴포넌트의 렌더링, 업데이트 결과를 jsdom에 반영할 때 사용해야 함
- React Testing Library의 `render 함수`와 `user-event`는 **내부적으로 act 함수를 호출**하기 때문에 편리하게 테스트 코드 작성이 가능
- 이외에 별도로 리액트 state를 업데이트하여 변경 사항을 검증해야 한다면 **act 함수를 사용하여 state를 반영**해야 함

## 타이머 테스트

**타이머 테스트**

- 타이머를 원하는대로 제어하기 위해서는 타이머 모킹이 필요하다.
- `useFakeTimers()`를 통해 타이머를 모킹할 수 있으며, `advanceTimersByTime()`을 통해 시간이 흐른 것처럼 제어할 수 있다.
- `setSystemTime()`을 통해 테스트가 구동되는 현재 시간을 정의할 수 있다.

**타이머 복원**

- 테스트가 실행된 후 다른 테스트에 영향을 주지 않기 위해 타이머 모킹을 해제해야 한다.
- `useRealTimers()`를 호출해 타이머를 원래대로 되돌릴 수 있다.

## userEvent를 사용한 사용자 상호작용 테스트

**fireEvent**

- `@testing-library/react` 모듈에 내장되어 제공
- 특정 요소에서 원하는 이벤트만 쉽게 발생시킬 수 있음

**fireEvent vs userEvent**

- fireEvent는 DOM 이벤트만 발생시키는 반면, userEvent는 다양한 상호 작용을 시뮬레이션 할 수 있음
- 클릭 이벤트가 발생한다면.. `pointerdown`, `mousedown`, `pointerup`, `mouseup`, `click`, `focus`가 연쇄적으로 발생
- 실제 상황처럼 disabled된 버튼이나 인풋 입력이 불가능함
- 테스트 코드 작성 시에는 `userEvent`를 활용해 실제 상황과 유사한 코드로 테스트의 신뢰성을 높이자
- `userEvent`에서 지원하지 않는 부분이 있을 때, `fireEvent` 활용을 고민하자
