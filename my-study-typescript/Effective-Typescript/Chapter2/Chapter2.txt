🌊 2장 타입스크립트의 타입 시스템

타입스크립트는 '코드를 자바스크립트로 변환'하는 역할도 하지만,

    가장 중요한 역할은 🔥'타입 시스템'🔥

    1. 편집기를 사용하여 타입 시스템 탐색하기

        타입스크립트를 설치하면 실행할 수 있는 2가지
            1) 타입스크립트 컴파일러(tsc)
            2) 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

        보통은 타입스크립트 컴파일러(tsc)를 실행하는 것이 주목적
        그렇지만, 타입스크립트 서버 또한 '언어 서비스'를 제공한다는 점에서 중요 !
                                         -------------------

        언어 서비스 ?
            코드 자동 완성, 명세(사양) 검사, 검색, 리팩터링이 포함

        보통은 편집기를 통해서 언어 서비스를 사용하는데, 타입스크립트 서버에서 언어 서비스를 제공하도록 설정하는 것이 좋음
        -> 유용한 기능이니 꼭 사용하자

        보통의 경우, 심벌 위에 마우스 커서를 대면 타입스크립트가 그 타입을 어떻게 판단하고 있는지 확인할 수 있다.

            let num = 10;
            --> num 변수의 타입을 number라고 직접 지정하지는 않았지만, 타입스크립트는 10이라는 값을 보고 그 타입을 알아낸다.

        
        * 특정 시점에 타입스크립트가 값의 타입을 어떻게 이해하고 있는지 살펴보는 것은
          타입 넓히기와 좁히기의 개념을 잡기 위해 꼭 필요한 과정

          --> 조건문의 분기에서 값의 타입이 어떻게 변하는지 살펴보는 것은 시스템을 연마하는 매우 좋은 방법 !

            function logMessage(message: string | null) {
                if (message) {
                    // message: string  추론
                }
            }

        * 편집기상의 오류를 살펴보는 것도 타입 시스템의 성향을 파악하는 데 좋은 방법 !

        * 언어 서비스는 라이브러리와 라이브러리의 타입 선언을 탐색할 때 도움이 된다.
          ==> 라이브러리의 객체들을 ctrl+click하게 되면 나오는 타입들 보기 !

          ==> 많은 타입들을 탐색하다 보면,
              처음에는 이해하기 어렵지만, 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링 되었는지,
              어떻게 오류를 찾아낼지 살펴볼 수 있다.

----------------------------------------------------------------------------------------------------------------------------------------

    2. 타입이 값들의 집합이라고 생각하기
        런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다.
        변수에는 다음처럼 다양한 종류의 값을 할당할 수 있다.

            42
            null
            undefined
            'Canada'
            { animal: 'Whale', weight_lbs: 40_000 }
            /regex/
            new HTMLButtonElement
            (x, y) => x + y

        그러나 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 '타입'을 가지고 있다.

        🟢 타입 = 할당 가능한 값들의 집합 = 범위 🟢

            1) 가장 작은 집합 --> 아무 값도 포함하지 않는 공집합 --> never 타입
                never 타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 X

            2) 그 다음으로 작은 집합은 한 가지 값만 포함하는 타입 --> unit 타입이라고 불리는 literal 타입

        ✨ 타입 체커의 역할은 !!
            하나의 집합이 다른 집합의 부분 집합인지 검사하는 것 !

        ✨ 타입스크립트 타입이 되지 못하는 값의 집합들이 있다.
            정수에 대한 타입, 또는 x와 y 속성 외에 다른 속성이 없는 객체는 타입스크립트 타입에 존재 x

        ✨✨ 'A는 B를 상속' =  'A는 B에 할당 가능' =  'A는 B의 서브타입' = 'A는 B의 부분집합'

-----------------------------------------------------------------------------------------------------------------

    3. 타입 공간과 값 공간의 심벌 구분하기

        타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중의 한 곳에 존재
                                     --------------------------------------
        심벌은 이름이 같더라도, 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있음

            interface Cylinder {
                      --------
                radius: number;
                height: number;
            }

            const Cylinder = ( radius: number, height: number ) => ({ radius, height });
                  --------

            ==> interface Cylinder에서 Cylinder는 타입으로 쓰인다.
                Cylinder에서 Cylinder와 이름은 같지만 값으로 쓰이며, 서로 관련도 없다....
            
            ==> 상황에 따라서 Cylinder는 타입으로 쓰일 수 있고, 값으로 쓰일 수도 있다.

            그런데 다음과 같은 점이 오류를 야기하기도...

                function calculateVolume(shape: unknown) {
                    if(shape instanceof Cylinder) {
                        shape.radius // '{}' 형식에 'radius' 속성이 없습니다.
                    }
                }

                ==> 오류를 살펴보자

                    아마도 instanceof를 이용해 shape가 Cylinder 타입인지 체크하려고 했을 것
                    그러나 instanceof는 자바스크립트 런타임 연산자이고, 값에 대해서 연산을 한다.
                    그래서 instnaceof Cylinder는 타입이 아니라 함수를 참조한다.
                                                 ------------------------

            🟢 한 심벌이 타입인지 값인지는 언뜻 봐서는 알 수 없다.
              => 어떤 형태로 쓰이는지 문맥을 살펴 알아내야 한다.

              type T1 = 'string literal';
              type T2 = 123;
              const v1 = 'string literal';
              const v2 = 123;

              일반적으로 type이나 interface 다음에 나오는 심벌은 타입인 반면, const나 let 선언에 쓰이는 것은 값 !

            🟢 두 공간에 대한 개념을 잡으려면 '타입스크립트 플레이그라운드'를 활용해보자
              
              플레이 그라운드
                - 타입스크립트 소스로부터 변환된 자바스크립트 결과물을 보여준다.
                - 컴파일 과정에서 타입 정보는 제거되기 때문에, 심벌이 사라진다면 그것은 타입에 해당될 것 !

            🟢 타입스크립트 코드에서 타입과 값은 번갈아 나올 수 있다.
              타입 선언(:) 또는 단언문(as) 다음에 나오는 심벌은 타입인 반면, = 다음에 나오는 모든 것은 값이다.

            🟢 class와 enum은 상황에 따라 타입과 값 두 가지 모두 가능한 예약어이다.

            🟢 typeof는 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 한다.
                         -----------------------------------------

                type T1 = typeof p; // 타입은 Person
                type T2 = typeof email;
                    // 타입은 (p: Person, subject: string, body: string) => Response

                const v1 = typeof p; // 값은 "object"
                const v2 = typeof email; // 값은 "function"

                - 타입의 관점에서, typeof는 값을 읽어서 타입스크립트 타입을 반환
                - 값의 관점에서, typeof는 자바스크립트 런타임의 typeof 연산자가 된다.
                    - 심벌의 런타임 타입을 가리키는 문자열을 반환

            🟢 타입스크립트 타입의 종류가 무수히 많은 반면,
                자바스크립트에는 과거부터 지금까지 단 6개
                    - string
                    - number
                    - boolean
                    - undefined
                    - object
                    - function

            🟢 class 키워드는 값과 타입 두 가지로 모두 사용된다.
                따라서 클래스에 대한 typeof는 상황에 따라 다르게 동작한다.

                class Cylinder {
                    radius=1;
                    height=1;
                }

                const v = typeof Cylinder; // 값이 'function'
                type T = typeof Cylinder; // 타입이 typeof Cylinder

                * 여기서 중요한 것은 Cylinder가 인스턴스의 타입이 아니라는 점 !
                    실제로는 new 키워드를 사용할 때 볼 수 있는 생성자 함수

                declare let fn: T;
                const c = new fn(); // 타입이 Cylinder

                * 다음 코드처럼 InstanceType 제네릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있음

                    type C = InstanceType<typeof Cylinder>; // 타입이 Cylinder

            🟢 속성 접근자인 []는 타입으로 쓰일 때에도 동일하게 동작한다.
                그러나 obj['field']와 obj.field는 값이 동일하더라도 타입은 다를 수 있다.
                따라서 타입의 속성을 얻을 때에는 반드시 첫 번째 방법(obj['field'])를 사용해야 한다.

                    const first: Person['first'] = p['first']; // 또는 p.first
                          ---값  ------------타입  -------값

                    type PersonEl = Person['first' | 'last']; // 타입은 string
                    type Tuple = [string, number, Date];
                    type TupleEl = Tuple[number]; // 타입은 string | number | Date

            🟢 두 공간 사이에서 다른 의미를 가지는 코드 패턴들이 있다

                - 값으로 쓰이는 this는 자바스크립트의 this 키워드이다.
                  타입으로 쓰이는 this는, 일명 '다형성(polymorphic) this'라고 불리는 this의 타입스크립트 타입이다.
                
                - 값에서 &와 |는 AND와 OR 비트연산이다.
                  타입에서는 인터섹션과 유니온이다.

                - const는 새 변수를 선언하지마, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꾼다.

                - extends는 서브 클래스(class A extends B) 또는 서브 타입(interface A extends B) 또는
                  제너릭 타입의 한정자(Generic<T extends number>)를 정의할 수 있다

                - in은 루프(for (key in object)) 또는 매핑된(mapped) 타입에 등장한다

                ==> 타입스크립트 코드가 잘 동작하지 않는다면
                    타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 크다.

                    예를 들어, 단일 객체 매개변수를 받도록 email 함수를 변경했다고 생각해보자

                        function email(options: { person: Person, subject: string, body: string }) {
                            // ...
                        }

                        자바스크립트에서는 객체 내의 각 속성을 로컬 변수로 만들어 주는 구조 분해(destructuring) 할당을 사용할 수 있다.

                        function email({person, subject, body}) { ... }

                        🔴 그런데 타입스크립트에서 구조 분해 할당을 하면, 이상한 오류가 발생한다.

                            function email({
                                person: Person, // 바인딩 요소 'Person'에 암시적으로 'any' 형식이 있습니다
                                subject: string,
                                body: string,
                            })

                            ✨ 값의 관점에서 Person과 string이 해석되었기 때문에 오류가 발생했다.
                                문제를 해결하려면 타입과 값을 구분해야 한다.

                                function email(
                                    {person, subject, body}: {person: Person, subject: string, body: string}
                                ) {
                                    // ...
                                }

                                ==> 이 코드는 장황하긴 하지만,
                                    매개변수에 명명된 타입을 사용하거나 문맥에서 추론되도록 잘 동작한다.

-----------------------------------------------------------------------------------------------------------------

    4. 타입 단언보다는 타입 선언을 사용하기

        타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 2가지 !

            interface Person { name: string }

            const alice: Person = { name: 'Alice' }; // 타입은 Person
            const bob: { name: 'Bob' } as Person; // 타입은 Person

        🔴 이 두 가지 방법은 결과가 같아 보이지만 그렇지 않다 !

            첫 번째 alice: Person은 변수에 '타입 선언'을 붙여서 그 값이 선언된 타입임을 명시한다.
            두 번째 as Person은 '타입 단언'을 수행한다. 그러면 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.

            ✨ 타입 단어(as Person)보다 타입 선언(:Person)을 사용하는 게 낫다.

                    const alice: Person = {}; // 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.
                    const bob = {} as Person; // 오류 없음

                    ==> 타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.
                        타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.

            ✨ 타입 선언과 단언의 차이는 속성을 추가할 때도 마찬가지

                const alice: Person {
                    name: 'Alice',
                    occupation: 'TypeScript developer', // 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Person' 형식에 'occupation'이(가) 없습니다.
                };

                const bob = {
                    name: 'Bob',
                    occupation: 'JavaScript developer'
                } as Person; // 오류 없음

            ✨ 타입 단언이 꼭 필요한 경우가 아니라면, 안전성 체크도 되는 타입 선언을 사용하는 것이 좋다.
                                                      ----------------------------------
                🏷️ 아마 const bob = <Person>{} 같은 코드를 본 적이 있을텐데, 이 코드는 단언문의 원래 문법이며 {} as Person과 동일
                    그러나 const bob = <person>{} 같은 코드는 <Person>이 .tsc(타입스크립트 + 리액트)에서 컴포넌트 태그로 인식되기 때문에 현재는 잘 쓰이지 않는다.

               * 화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있다.

                    예를 들어, 다음 코드에서 Person 인터페이스를 사용하고 싶다고 가정해보자

                        const people = ['alice', 'bob', 'jan'].map(name => ({ name }));
                        // Person[]을 원했지만 결과는 { name: string; }[]...

                        {name}에 타입 단언을 쓰면 문제가 해결되는 것처럼 보인다.
                        ---> const people = ['alice', 'bob', 'jan'].map(name => ({ name } as Person)); // 타입은 Person[]

                        🔴 그러나 타입 단언을 사용하면 런타임에 문제가 발생

                            const people = ['alice', 'bob', 'jan'].map(name => ({} as Person)); // 오류 없음

                        🟢 단언문을 쓰지 않고, 다음과 같이 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적

                                const people = ['alice', 'bob', 'jan'].map(name => {
                                    const person: Person = { name };
                                    return person;
                                }); // 타입은 Person[]

                            그러나 원래 코드에 비해 꽤나 번잡해 보인다. 좀 더 간결하게 하면 다음과 같다.

                                const people = ['alice', 'bob', 'jan'].map((name): Person => ({ name })); // 타입은 Person[]

                            (name): Person은 name의 타입이 없고, 반환 타입이 Person이라고 명시.
                            그러나 (name: Person)은 name의 타입이 Person임을 명시하고 반환 타입은 없기 때문에 오류가 발생

                            ✨ 다음 코드는 최종적으로 원하는 타입을 명시하고, 타입스크립트가 할당문의 유효성을 검사하게 한다.

                                const people: Person[] = ['alice', 'bob', 'jan'].map((name): Person => ({ name }));

                        🟢 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 한다.

            ✨ 타입 단언이 꼭 필요한 경우

                타입 단언은 타입 체커가 추론한 타입보다 내가 판단하는 타입이 더 정확할 때 의미가 있다.

                1) 예를 들어, DOM 엘리먼트에 대해서는 타입스크립트보다 개발자가 더 잘 알고 있을 것이다.

                    document.querySelector('#myButton').addEventListener('click', e => {
                        e.currentTarget // 타입은 EventTarget
                        const button = e.currentTarget as HTMLButtonElement;
                        button // 타입은 HTMLButtonElement
                    });

                    타입스크립트는 DOM에 접근할 수 없기 때문에 #myButton이 버튼 엘리먼트인지 알지 못한다.
                    그리고 이벤트의 currentTarget이 같은 버튼이어야 하는 것도 알지 못한다.
                    
                    우리는 타입스크립트가 알지 못하는 정보를 가지고 있기 때문에 여기서는 타입 단언문을 쓰는 것이 타당하다.

                2) 자주 쓰이는 특별한 문법(!)을 사용해서 null이 아님을 단언하는 경우도 있다.

                    const elNull = document.getElementById('foo'); // 타입은 HTMLElement | null
                    const el = document.getElementById('foo'); // 타입은 HTMLElement

                    변수의 접두사로 쓰인 !는 boolean의 부정문이다. ex. const [isOpen, setIsOpen] = useState(false); , setIsOpen(prev => !prev)
                    
                    🟢 그러나 접미사로 쓰인 !는 그 값이 null이 아니라는 단언문으로 해석된다.
                        => 단언문은 컴파일 과정 중에 제거되므로, 타입 체커는 알지 못하지만 그 값이 null이 아니라고 확신할 수 있을 때 사용해야 한다.
                           만약 확신할 수 있는 상황까지는 아니라면, null인 경우를 체크하는 조건문을 사용해야 한다.

                3) 타입 단언문으로 임의의 타입 간에 변환을 할 수는 없다. A가 B의 부분집합인 경우에 타입 단언문을 사용해 변환할 수 있다.

                    HTMLElement는 HTMLElement | null의 서브타입이기 때문에 이러한 타입 단언은 동작한다.
                    HTMLButtonElement는 EventTarget의 서브타입이기 때문에 역시 동작한다.
                    그리고 Person은 {}dml 서브타입이므로 동작한다.
                    
                    그러나 Person과 HTMLElement는 서로의 서브타입이 아니기 때문에 변환이 불가능

                    interface Person { name: string; }
                    const body = document.body;
                    const el = body as Person;
                        // ~~~~~~~~~~~~~~~~~~~ 'HTMLElement' 형식을 'Person' 형식으로 변환하는 것은
                                                형식이 다른 형식과 충분히 겹치지 않기 때문에
                                                실수일 수 있습니다. 이것이 의도적인 경우에는
                                                먼저 식을 'unknown'으로 변환하십시오.

                    이 오류를 해결하려면 unknown타입을 사용해야 한다.
                    모든 타입은 unknown의 서브타입이기 때문에 unknown이 포함된 단언문은 항상 동작한다.
                    unknown 단언은 임의의 타입 간에 변환을 가능케 하짐나, unknown을 사용한 이상 적어도 무언가 위함한 동작......

                    const el = document.body as unknown as Person; // 정상

-----------------------------------------------------------------------------------------------------------------------------------------------------------

    5. 객체 래퍼 타입 피하기

        자바스크립틍는 객체 이외에도 기본형 값들에 대한 일곱 가지 타입이 존재

            string, number, boolean, null, undefined, symbol, bigint
            => 기본형들은 불변(immutable)이며 메서드를 가지지 않는 다는 점에서 객체와 구분됨

            그런데 기본형인 string, number의 경우 메서드를 가지고 있지 않나 ?
            > 'primitive'.charAt(3) "m"

                ==> 하지만 사실 chatAt은 string의 메서드가 아니며, string을 사용할 때 자바스크립트 내부적으로 많은 동작이 일어남
                    string '기본형'에는 메서드가 없지만, 자바스크립트에는 메서드를 가지는 String'객체' 타입이 정의되어 있다.
                                                        --------------------------------------------------
                    🟢 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환한다.

                        ✨ string 기본형에 chatAt같은 메서드를 사용할 때, 
                            자바스크립트 기본형을 String 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버린다.

                    만약 String.prototype을 몽키-패치(monkey-patch)한다면 앞서 설명한 내부적인 동작들을 관찰할 수 있다.

                        * 몽키-패치(monkey-patch)
                            런타임에 프로그램의 어떤 기능을 수정해서 사용하는 기법을 의미
                            자바스크립트에서는 주로 프로토타입을 변경하는 것이 해당된다.

                        // 실제로는 이렇게 하지말자
                        const originalCharAt = String.prototype.charAt;
                        String.prototype.charAt = function(pos) {
                            console.log(this, typeof this, pos);
                            return originalCharAt(this, pos);
                        }
                        console.log('primitive'.charAt(3));

                        이 코드는 다음을 출력한다.

                        [String: 'primitive'] 'Object' 3
                        m

                        메서드 내의 this는 string 기본형이 아닌 String 래퍼 객체이다.
                        String 객체를 직접 생성할 수도 있으며, string 기본형처럼 동작한다.

                        🟢 그러나 string 기본형과 String 객체 래퍼가 항상 동일하게 동작하는 것은 아니다.

                            예를 들어 String 객체는 오직 자기 자신하고만 동일하다.

                            > "hello" === new String("hello")
                            false

                            > new String("hello") === new String("hello")
                            false

                        🟢 객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보일 때가 있다.
                        
                            예를 들어 어떤 속성을 기본형에 할당한다면 그 속성이 사라진다.

                            > x = 'hello'
                            > x.language = 'English'
                            'English'
                            > x.language
                            undefined

                            실제로는 x가 String 객체로 변환된 후 language 속성이 추가되었고, language 속성이 추가된 객체는 버려진 것!

                    다른 기본형에도 동일하게 객체 래퍼 타입이 존재
                        number - Number, boolean - Boolean, symbol - Symbol, bigint - bigInt
                        * null과 undefined에는 객체 래퍼가 없다.

                        ==> 이 래퍼 타입들 덕분에 기본형 값에 메서드를 사용할 수 있고,
                            정적 메서드(String.fromCharCode 같은)도 사용할 수 있다.

                            그러나 래퍼 객체를 직접 생성할 필요가 없다.

                    🟢 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다.
                       ---------------------------------------------------------

                        그러나 string을 String이라고 잘못 타이핑하기 쉽고, 실수를 하더라도 처음에는 잘 동작하는 것처럼 보이기 때문에 !

                        function getStringLen(foo: String) {
                            return foo.length;
                        }

                        getStringLen("hello"); // 정상
                        getStringLen(new String("hello")); // 정상

                        그러나 string을 매개변수로 받는 메서드에 String 객체를 전달하는 순간 문제가 발생

                        ===> ✨ string은 String에 할당할 수 있지만, String은 string에 할당할 수 없다.

                                대부분의 라이브러리와 마찬가지로 타입스크립트가 제공하는 타입 선언은 전부 기본형 타입으로 되어 있다.

                    🟢 래퍼 객체는 타입 구문의 첫 글자를 대문자로 표기하는 방법으로도 사용할 수 있다.

                        const s: String = "primitive";
                        const n: Number = 12;
                        const b: Boolean = true;

                        당연히 런타임의 값은 객체가 아니고 기본형이다.
                        그러나 기본형 타입은 객체 래퍼에 할당할 수 있기 때문에 타입스크립트는 기본형 타입을 객체 래퍼에 할당하는 선언을 허용한다.

                        그러나 기본형 타입을 객체 래퍼에 할당하는 구문은 오해하기 쉽고, 굳이 그렇게 할 필요도 없다.
                        -> 그냥 기본형 타입을 사용하는 것이 낫다.

                        그런데 new 없이 BigInt와 Symbol를 호출하는 경우는 기본형을 생성학리 때문에 사용해도 좋습니다.
                        
                        > typeof BigInt(1234)
                        "bigint"

                        > typeof Symbol("sym")
                        "symbol"

--------------------------------------------------------------------------------------------------------------------------------------------------
                
    6. 잉여 속성 체크의 한계 인지하기

        🏷️ 잉여 속성 체크 ?
            객체 리터럴이나 다른 객체 할당 시에, 타입으로 선언되지 않은 속성을
            포함하는 경우 경고나 오류를 발생시키는 기능

            기본적으로 타입스크립트는 정적 타입 검사를 수행하여 코드의 안정성을 높이는 역할을 한다.
            객체 리터럴을 사용하여 객체를 생성하거나 다른 객체에 할당할 때, 타입스크립트는 해당 타입으로 선언된 속성 외에 다른 속성이 있는지 검사
            이를 잉여 속성 체크라고 부른다.

        🟢 타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 '그 외 속성은 없는지' 확인

            (1)
            interface Room {
                numDoors: number;
                ceilingHeightFt: number;
            }
            const r: Room = {
                numDoors: 1,
                ceilingHeightFt: 10,
                elephant: 'present',
                // ~~~~~~~~~~~~~~~~~~~ 개체 리터럴은 알려진 속성만 지정할 수 있으며
                                        'Room' 형식에 'elephant'이(가) 없습니다.
            }

            Room 타입에 생뚱맞게 elephant 속성이 있는 것이 어색하긴 하지만,
            구조적 타이핑 관점으로 생각해 보면 오류가 발생하지 않아야 한다.
            임시 변수를 도입해 보면 알 수 있는데, obj 객체는 Room 타입에 할당이 가능하다.

            (2)
            const obj = {
                numDoors: 1,
                ceilingHeightFt: 10,
                elephant: 'present'
            }
            const r: Room = obj

            obj의 타입은 { numDoors: number; ceilingHeightFt: number; elephant: string }으로 추론된다.
            ✨ obj 타입은 Room 타입의 부분 집합을 포함하므로, Room에 할당이 가능하며 타입 체커도 통과 !

                (1)과 (2)의 차이점에 대해 살펴보자

                    ✨ (1)은 구조적 타입 시스템에서 발생할 수 있는 중요한 종류의 오류를 잡을 수 있도록 
                        '잉여 속성 체크'라는 과정이 수행되었다.

                        그러나 잉여 속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고,
                        통상적으로 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워질 수 있다.
                        잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야
                        타입스크립트 타입 시스템에 대한 개념을 잡을 수 있다.

                        아이템1에서 설명했듯이 타입스크립트는 단순히 런타임에 예외를 던지는 코드에 오류를 표시할 뿐만 아니라
                        의도와 다르게 작성된 코드까지 찾으려고 한다.

                            interface Options {
                                title: string'
                                darkMode: boolean;
                            }
                            function createWindow(options: Options) {
                                if(options.darkMode) {
                                    setDarkMode();
                                }
                                // ...
                            }
                            createWindow({
                                title: "Spider Solitaire",
                                darkmode: true,
                                // ~~~~~~~~~~~~~ 개체 리터럴은 알려진 속성만 지정할 수 있지만
                                                  'Options' 형식에 'darkmode'이(가) 없습니다.
                                                  'darkMode'을(를) 쓰려고 했습니까?
                            })

                            앞의 코드를 실행하면 런타임에 어떠한 종류의 오류도 발생하지 않는다.
                            그러나 타입스크립트가 알려주는 오류 메시지처럼 의도한 대로 동작하지 않을 수 있다.
                            오류가 발생한 부분은 darkmode가 아닌 darkMode이어야 한다.

                            ✨ Options 타입은 범위가 매우 넓기 때문에, 순수한 구조적 타입 체커는 이런 종류의 오류를 찾아내지 못한다.
                            darkMode의 속성에 boolean 타입이 아닌 다른 타입의 값이 지정된 경우를 제외하면,
                            string 타입인 title 속성에 '또 다른 어떤 속성'을 가지는 모든 객체는 Options 타입의 범위에 속한다.

                            ✨ 타입스크립트 타입은 범위가 아주 넓어질 수 있다.
                                여기에 Options에 할당할 수 있는 몇 가지 값이 더 있다.

                                const o1: Options = document; // 정상
                                const o2: Options = new HTMLAnchorElement; // 정상

                                ==> document와 HTMLAnchorElement의 인스턴스 모두 string 타입인 title 속성을 가지고 있기 때문에 할당문은 정상이다.

        🟢 잉여 속성 체크를 사용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 
           --------------
            객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써,
            앞에서 다룬 Room이나 Options 예제 같은 문제점을 방지할 수 있다.
            그래서 '엄격한 객체 리터럴 체크'라고 불린다.

            document난 new HTMLAnchorElement는 객체 리터럴이 아니기 때문에 잉여 속성 체크가 되지 않는다.

                🏷️ 객체 리터럴(Object Literal)
                    자바스크립트에서 객체를 생성하는 방법 중 하나
                    객체는 여러 속성(key-value pairs)를 포함하는 데이터 구조로, 객체 리터럴을 사용하여 속성과 값의 집합을 표현할 수 있다.

                    객체 리터럴은 중괄호({})를 사용하여 객체를 감싸고, 속성과 값은 콜록(:)으로 구분하여 정의한다.

                    const person = {
                        name: 'John',
                        age: 30
                    }

                    위의 코드에서 'person'은 객체 변수이며, 객체 리터럴을 사용하여 정의되었다.

                    ==> 객체 리터럴은 자바스크립트에서 객체를 간현하게 생성하고 초기화하는 방법 중 하나!

            그러나 { title, darkmode } 객체는 체크가 된다.

                const o: Options = { darkmode: true, title: 'Ski Free' };
                                    // ~~~~~~'Options' 형식에 'darkmode'이(가) 없습니다.

            오류가 사라지는 이유를 알아내기 위해 타입 구문 없는 임시 변수를 사용해보자

                const intermediate = { darkmode: true, title: 'Ski Free' };
                const o: Options: intermediate; // 정상

                ===> ✨ 첫 번째 줄의 오른쪽은 객체 리터럴이지만, 두 번째 줄의 오른쪽(intermediate)은 객체 리터럴이 아니다.
                        따라서 잉여 속성 체크가 적용되지 않고 오류는 사라진다.

        🟢 잉여 속성 체크는 타입 단언문을 사용할 때에도 적용 x

            const o = { darkmode: true, title: 'Ski Free' } as Options; // 정상

            => 이 예제가 단언문보다 선언문을 사용해야 하는 단적인 이유 중 하나이다.

        🟢 잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.

            interface Options {
                darkMode?: boolean;
                [otherOptions:: string]: unknown;
            }

            const o: Options: {darkmode: true}; // 정상

        🟢 선택적 속성을 가지는 '약한(weak)' 타입에도 비슷하게 체크가 동작

                interface LineChartOptions {
                    logscale?: boolean;
                    invertedYAxis?: boolean;
                    areaChart?: boolean;
                }
                const opts: { logScale: true };
                const o: LineChartOptions = opts;
                    // ~ '{ logScale: boolean }' 유형에 'LineChartOptions' 유형과 공통적인 속성이 없습니다.

             구조적 관점에서 LineChartOptions 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다.
             이런 약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행

             공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는 데 효과적이며 구조적으로 엄격하지 않다.

             그러나 잉여 속성 체크와 다르게, 약한 타입과 관련된 할당문마다 수행된다.
             임시 변수를 제거하더라도 공통 속성 체크는 여전히 동작한다.

            
        🟢 잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름의 오타 같은 실수를 잡는 데 효과적

---------------------------------------------------------------------------------------------------------------------------------------

    7. 함수 표현식에 타입 적용하기

        자바스크립트(그리고 타입스크립트)에서는 함수 '문장(statement)'과 함수 '표현식(expression)'을 다르게 인식한다.
                                               ---------------------------------------------------------------
            function rollDice1(sides: number): number { ... }               // 문장
            const rollDice2 = function(sides: number): number { ... }       // 표현식
            const rollDice3 = (sides: number): number => { ... }            // 표현식

        타입스크립트에서는 함수 표현식을 쓰는 것이 좋다.
        함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식을 재사용할 수 있다는 장점이 있기 때문

            type DiceRollFn = (sides: number) => number;
            const rollDice: DiceRollFn = sides => { ... };

        함수 타입 선언의 장점을 알아보자.

            🟢 함수 타입의 선언은 불필요한 코드의 반복을 줄인다.
                function add(a: number, b: number) { return a + b };
                function sub(a: number, b: number) { return a - b };
                function mul(a: number, b: number) { return a * b };
                function div(a: number, b: number) { return a / b };

                반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수 있다.

                    => type BinaryFn = (a: number, b: number) => number;
                        const add: BinaryFn = (a, b) => a + b
                        const sub: BinaryFn = (a, b) => a - b
                        ...
                    ==> 이전 코드보다 타입 구문이 적다.
                    ==> 그리고, 함수 구현부도 분리되어 있어 로직이 보다 분명해진다.

                * 시그니처가 일치하는 다른 함수가 있을 때도 함수 표현식에 타입을 적용해볼만 하다.

                    예를 들어, 웹 브라우저에서 fetch 함수는 특정 리소스에 HTTP 요청을 보낸다.
                        const responseP = fetch('/quote?by=Mark+Twain'); // 타입이 Promise<Response>

                    그리고 response.json() 또는 response.text()를 사용해 응답의 데이터를 추출한다.
                        async function getQuote() {
                            const response = await fetch('/quote?by=Mark+Twain');
                            const quote = await response.json();
                            return quote;
                        }
                        
                        여기에 버그가 있다.
                        /quote가 존재하지 않는 API라면, '404 NOT FOUND'가 포함된 내용을 응답한다.
                        => 즉, 응답이 JSON 형식이 아닐 수 있다.
                        => 이럴 때는 response.json()이 JSON 형식이 아니라는 새로운 오류 메시지를 담아 거절된(rejected) 프로미스를 반환한다.

                        또한 fetch가 실패하면 거절된 프로미스를 응답하지는 않는다는 걸 간과하기 쉽다.
                        그러니 상태 체크를 수행해 줄 checkedFetch 함수를 작성해 작성해 보겠다.

                            declare function fetch(
                                input: RequestInfo, init?: RequestInit
                            ): Promise<Response>;

                        checkedFetch는 다음처럼 작성할 수 있다.

                            async function checkedFetch(input: RequestInfo, init?: RequestInit) {
                                const response = await fetch(input, init);
                                if(!response.ok) {
                                    // 비동기 함수 내에서는 거절된 프로미스를 반환한다.
                                    throw new Error("Request failed: " + response.status);
                                }
                                return response;
                            }
                        
                        이 코드도 잘 동작하지만, 다음과 같이 더 간결하게 작성할 수 있다.

                            const checkedFetch: typeof fetch = async (input, init) => {
                                const response = await fetch(input, init);
                                if(!response.ok) {
                                    throw new Error("Request failed" + response.status);
                                }
                                return response;
                            }

                        함수 문장을 함수 표현식으로 바꿨고, 함수 전체에 타입(typeof fetch)을 적용했다.
                        이는 타입스크립트가 input과 init의 타입을 추론할 수 있게 해준다.

                        타입 구문은 또한 checkedFetch의 반환 타입을 보장하며, fetch와 동일하다.
                        예를 들어 throw 대신 return을 사용했다면, 타입스크립트는 그 실수를 잡아낸다.

                            const checkedFetch: typeof fetch = async (input, init) => {
                                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 'Promise<Response | Error>' 형식은
                                                                                                'Promise<Response>' 형식에 할당할 수 없습니다.
                                const response = await fetch(input, init);
                                if(!response.ok) {
                                    return new Error("Request failed" + response.status);
                                }
                                return response;
                            }

                        ✨ checkedFetch를 함수 문장으로 작성한 예시에서도 throw가 아닌 return을 사용할 경우 오류가 발생한다.
                            그러나 오류는 첫 번째 예제와 달리 checkedFetch 구현체가 아닌, 함수를 호출한 위치에서 발생

            🟢 함수의 매개변수에 타입을 선언하는 것보다 함수 표현식 전체 타입을 정의하는 것이 코드도 간결하고 안전하다.
                다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나,
                동일한 타입 시그니처를 가지는 여러 개의 함수를 작성할 때는 매개변수의 타입과 반환 타입을 반복해서 작성하지 말고
                함수 전체를 타입 선언을 적용해야 한다.

            🟢 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

------------------------------------------------------------------------------------------------------------------------------------------